<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"159357254680.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.21.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="blog">
<meta property="og:url" content="https://159357254680.github.io/index.html">
<meta property="og:site_name" content="blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://159357254680.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://159357254680.github.io/2025/03/17/http%E4%B8%8EWebSocket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/03/17/http%E4%B8%8EWebSocket/" class="post-title-link" itemprop="url">http与WebSocket</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-03-17 19:34:58" itemprop="dateCreated datePublished" datetime="2025-03-17T19:34:58+08:00">2025-03-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-03-23 13:02:23" itemprop="dateModified" datetime="2025-03-23T13:02:23+08:00">2025-03-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-http"><a href="#1-http" class="headerlink" title="1. http"></a>1. http</h1><h2 id="1-1-什么是http："><a href="#1-1-什么是http：" class="headerlink" title="1.1 什么是http："></a>1.1 什么是http：</h2><p>​	http，即超文本传输协议，是TCP&#x2F;IP协议集中的一个应用层协议，是客户端与服务端进行交互时必须遵循的规则。它用于Web浏览器与Web服务器之间交换数据的过程以及数据本身的格式，底层则是靠TCP进行可靠地信息传输。</p>
<p><strong>附</strong>：除了http，我们经常能够看见https。https不是http地复数，而是在http的基础上进行了加密工作，具体在后文进行介绍。</p>
<h2 id="1-2-http如何工作："><a href="#1-2-http如何工作：" class="headerlink" title="1.2 http如何工作："></a>1.2 http如何工作：</h2><p>​	在浏览器的上方，有一个地址栏。如果我们在其中输入一个URL,浏览器就会给对应的服务器发送一个http请求，当服务器收到这个请求之后，就会进行处理，然后返回一个http响应。那么，具体的过程是怎样的呢？</p>
<ol>
<li><strong>建立连接</strong>：客户端（如Web浏览器）与服务器建立连接。这个连接是通过TCP协议完成的，期间经过了三次握手。HTTP协议是短连接的，每次请求都需要建立一个新的连接。（http&#x2F;1.1后又引入了持久连接Keep-Alive，通过复用TCP连接来发送多个http请求和接受多个响应）</li>
<li><strong>发送请求</strong>：客户端向服务器发送请求。请求的格式包括请求行、请求头和请求体。请求行包含请求方法（如GET、POST）、请求的URL和HTTP版本。请求头包含一些附加信息，如主机、用户代理等。请求体则包含实际的数据。</li>
<li><strong>服务器响应</strong>：服务器接收到请求后，进行处理并返回响应。响应的格式包括状态行、响应头和响应体。状态行包含HTTP版本、状态码和状态描述。响应头包含一些附加信息，如服务器类型、内容类型等。响应体则包含实际的数据，如HTML文档。</li>
<li><strong>关闭连接</strong>：服务器发送完响应后，关闭连接。HTTP是无状态的协议，这意味着每次请求和响应都是独立的，服务器不会保留连接的状态信息。</li>
</ol>
<p>具体如下：</p>
<p>​	<img src="https://th.bing.com/th/id/OIP.YZt-rVLQzDPDZNIff5QXlAHaE6?w=242&h=180&c=7&r=0&o=5&dpr=2&pid=1.7" alt="示例图片"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>

<ul>
<li><code>GET /index.html HTTP/1.1</code>：请求方法+资源路径+HTTP 版本</li>
<li><code>Host: www.example.com</code>：目标服务器地址</li>
<li><code>User-Agent: Mozilla/5.0 ...</code>：客户端类型（浏览器、操作系统等）</li>
<li><code>Accept: text/html,...</code>：客户端可接受的数据类型</li>
<li><code>Accept-Encoding: gzip,...</code>：支持的压缩格式</li>
<li><code>Connection: keep-alive</code>：连接方式，是否保持连接</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Wed, 19 Mar 2025 12:00:00 GMT</span><br><span class="line">Server: Apache/2.4.41 (Ubuntu)</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Content-Length: 1024</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;&lt;title&gt;示例&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">  &lt;body&gt;&lt;h1&gt;姜圣！&lt;/h1&gt;&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>HTTP/1.1 200 OK</code>：HTTP 版本 + 状态码 + 状态信息</li>
<li><code>Date: Wed, 19 Mar 2025 12:00:00 GMT</code>：响应时间</li>
<li><code>Server: Apache/2.4.41 (Ubuntu)</code>：服务器信息</li>
<li><code>Content-Length: 1024</code>：响应体大小（字节数）</li>
<li><code>Connection: keep-alive</code>：连接方式，支持长连接</li>
<li><code>响应体</code>：<code>&lt;html&gt;...&lt;/html&gt;</code> 是服务器返回的 HTML 页面</li>
</ul>
<p>**短连接：HTTP&#x2F;1.0 及默认情况，请求完成后关闭连接：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: close</span><br></pre></td></tr></table></figure>

<p><strong>长连接</strong>：HTTP&#x2F;1.1 及以上默认启用长连接：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>

<hr>
<p>省流就是：<strong>一发一收，一问一答</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/02dac5e6e5044a8d9a1e663ec55d8abe.png" alt="示例图片"></p>
<p>当然，在http&#x2F;2中，还可以实现其他的模式：</p>
<ul>
<li><h6 id="一发多收（一个请求，多个响应）"><a href="#一发多收（一个请求，多个响应）" class="headerlink" title="一发多收（一个请求，多个响应）"></a><strong>一发多收（一个请求，多个响应）</strong></h6></li>
<li><h6 id="多发一收（多个请求，一个响应）"><a href="#多发一收（多个请求，一个响应）" class="headerlink" title="多发一收（多个请求，一个响应）"></a><strong>多发一收（多个请求，一个响应）</strong></h6></li>
<li><h6 id="多发多收（多个请求，多个响应）"><a href="#多发多收（多个请求，多个响应）" class="headerlink" title="多发多收（多个请求，多个响应）"></a><strong>多发多收（多个请求，多个响应）</strong></h6></li>
</ul>
<p>当然都是后话了，等我下次再讲（又可以水一期分享了😋）</p>
<h2 id="1-3-http的方法："><a href="#1-3-http的方法：" class="headerlink" title="1.3 http的方法："></a>1.3 http的方法：</h2><h3 id="1-GET"><a href="#1-GET" class="headerlink" title="1. GET"></a>1. <strong>GET</strong></h3><ul>
<li><p><strong>作用</strong>：请求指定的资源。GET请求通常用于获取数据，而不会对资源产生副作用。</p>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>请求的参数附加在URL中（查询字符串）。</li>
<li>可以被缓存。</li>
<li>不应修改服务器上的资源。</li>
<li>幂等性</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>常见用途</strong>：</p>
<ul>
<li>获取网页内容。</li>
<li>查询数据库记录。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-POST"><a href="#2-POST" class="headerlink" title="2. POST"></a>2. <strong>POST</strong></h3><ul>
<li><p><strong>作用</strong>：向服务器提交数据，通常用于创建新资源或触发服务器上的处理操作。</p>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>请求的参数包含在请求体中。</li>
<li>不会被缓存。</li>
<li>可能会修改服务器上的资源。</li>
<li>不具有幂等性。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /submit-form HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">username=🫚&amp;password=123456</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>常见用途</strong>：</p>
<ul>
<li>提交表单数据。</li>
<li>上传文件。</li>
<li>创建新资源（如用户注册）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-PUT"><a href="#3-PUT" class="headerlink" title="3. PUT"></a>3. <strong>PUT</strong></h3><ul>
<li><p><strong>作用</strong>：更新指定资源。如果资源不存在，则创建新资源。</p>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>请求的参数包含在请求体中。</li>
<li>幂等性。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT /users/123 HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;: &quot;🦌🐟⚽&quot;, &quot;password&quot;: 159357&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>常见用途</strong>：</p>
<ul>
<li>更新用户信息。</li>
<li>替换现有资源。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-DELETE"><a href="#4-DELETE" class="headerlink" title="4. DELETE"></a>4. <strong>DELETE</strong></h3><ul>
<li><p><strong>作用</strong>：删除指定的资源。</p>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>幂等性。</li>
<li>请求通常没有请求体。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE /users/123 HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>常见用途</strong>：</p>
<ul>
<li>删除用户。</li>
<li>删除文件。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-HEAD"><a href="#5-HEAD" class="headerlink" title="5. HEAD"></a>5. <strong>HEAD</strong></h3><ul>
<li><p><strong>作用</strong>：请求资源的元信息，而不返回实际内容。</p>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>响应中没有响应体。</li>
<li>可以用于检查资源是否存在或获取资源的元信息（如大小、类型）。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HEAD /index.html HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>常见用途</strong>：</p>
<ul>
<li>检查资源是否更新（通过<code>Last-Modified</code>或<code>ETag</code>）。</li>
<li>获取资源的大小和类型。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="6-OPTIONS"><a href="#6-OPTIONS" class="headerlink" title="6. OPTIONS"></a>6. <strong>OPTIONS</strong></h3><ul>
<li><p><strong>作用</strong>：获取服务器支持的HTTP方法或其他选项。</p>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>响应中包含<code>Allow</code>头部，列出支持的HTTP方法。</li>
<li>幂等性</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS /index.html HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>常见用途</strong>：</p>
<ul>
<li>检查服务器支持的请求方法。</li>
<li>跨域请求时，用于预检请求（Preflight Request）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="7-TRACE"><a href="#7-TRACE" class="headerlink" title="7. TRACE"></a>7. <strong>TRACE</strong></h3><ul>
<li><p><strong>作用</strong>：用于诊断或测试，服务器会将收到的请求原样返回,以便客户端检查请求是否被篡改。</p>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>响应中包含客户端发送的请求信息。</li>
<li>通常用于调试。</li>
<li>幂等性</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TRACE /index.html HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>常见用途</strong>：</p>
<ul>
<li>检查请求在传输过程中是否被修改。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="8-CONNECT"><a href="#8-CONNECT" class="headerlink" title="8. CONNECT"></a>8. <strong>CONNECT</strong></h3><ul>
<li><p><strong>作用</strong>：用于建立与服务器的隧道连接，通常用于HTTPS代理。</p>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>请求中包含目标服务器的地址和端口。</li>
<li>用于客户端通过代理服务器与目标服务器建立连接。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONNECT www.example2.com:443 HTTP/1.1</span><br><span class="line">Host: www.example1.com</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>常见用途</strong>：</p>
<ul>
<li>通过代理服务器建立HTTPS连接。</li>
</ul>
</li>
</ul>
<hr>
<p>附图如下：</p>
<p><img src="https://img2020.cnblogs.com/blog/1430250/202010/1430250-20201007103219405-319114234.png" alt="示例图片"></p>
<p>​	<strong>幂等性：</strong>在忽略错误或过期问题的情况下，多次相同请求的副作用与一次请求的副作用相同。总结就是多次执行后效果相同，不存在副作用。而post每次请求都回创建新的资源，因此是不幂等的。</p>
<hr>
<h2 id="1-4-http的状态码"><a href="#1-4-http的状态码" class="headerlink" title="1.4 http的状态码"></a>1.4 http的状态码</h2><ul>
<li><p><strong>1xx（信息性状态码）</strong>：表示请求已被接收，继续处理。</p>
</li>
<li><p><strong>2xx（成功）</strong>：</p>
<ul>
<li><strong>200 OK</strong>：请求成功。</li>
<li><strong>201 Created</strong>：资源已创建。</li>
<li><strong>204 No Content</strong>：成功但无响应体。</li>
<li>**206 Partial Content :**范围请求成功</li>
</ul>
</li>
<li><p><strong>3xx（重定向）</strong>：</p>
<ul>
<li><strong>301 Moved Permanently</strong>：永久重定向（资源被分配了新的URI)。</li>
<li><strong>302 Found</strong>：临时重定向（资源被分配了新的URI，但是未来还有可能改变）。</li>
<li><strong>304 Not Modified</strong>：允许访问资源，但未满足条件。</li>
</ul>
</li>
<li><p><strong>4xx（客户端错误）</strong>：</p>
<ul>
<li><strong>400 Bad Request</strong>：请求语法错误。</li>
<li><strong>401 Unauthorized</strong>：未认证。</li>
<li><strong>403 Forbidden</strong>：无权限。</li>
<li><strong>404 Not Found</strong>：资源不存在。</li>
</ul>
</li>
<li><p><strong>5xx（服务器错误）</strong>：</p>
<ul>
<li><strong>500 Internal Server Error</strong>：服务器内部错误。</li>
<li><strong>502 Bad Gateway</strong>：网关错误。</li>
<li><strong>503 Service Unavailable</strong>：服务不可用（如武器超负载或正在维护）。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/183f18213593408bb7c612a2175ea749.png#pic_center" alt="示例图片"></p>
</li>
</ul>
<hr>
<h2 id="1-5-http的不足："><a href="#1-5-http的不足：" class="headerlink" title="1.5 http的不足："></a>1.5 http的不足：</h2><h3 id="1-无状态性"><a href="#1-无状态性" class="headerlink" title="1.无状态性"></a>1.<strong>无状态性</strong></h3><ul>
<li><p><strong>问题</strong>：</p>
<p>​	HTTP是无状态协议，服务器不会记住客户端的状态。每次请求都是独立的，服务器不会保留之前的请求信息。</p>
</li>
<li><p><strong>影响</strong>：</p>
<ul>
<li>增加了开发和维护的复杂性。</li>
<li>需要额外的机制（如Cookie、Session，补充在附录）来管理状态。</li>
</ul>
</li>
<li><p><strong>改进</strong>：</p>
<ul>
<li>使用Cookie或Session来管理状态。</li>
<li>使用Token进行无状态认证。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-安全问题"><a href="#2-安全问题" class="headerlink" title="2.安全问题"></a>2.安全问题</h3><p><strong>问题：</strong></p>
<ul>
<li>通信采用明文，内容可能被窃听</li>
<li>不验证通信双方的身份，可能遭遇伪装</li>
<li>无法验证明文的完整性，有可能遭到篡改</li>
</ul>
<p><strong>改进</strong>：</p>
<p>​	诞生了https，使用https（http over SSL&#x2F;TLS）加密传输数据。</p>
<p>（https见附录）</p>
<hr>
<h3 id="3-头部冗余"><a href="#3-头部冗余" class="headerlink" title="3. 头部冗余"></a>3. <strong>头部冗余</strong></h3><p><strong>问题</strong>：</p>
<p>​	HTTP请求和响应的头部信息是文本格式的，且每次请求都会发送完整的头部信息，导致冗余。</p>
<p><strong>改进</strong>：</p>
<p>​	http&#x2F;2引入了头部压缩（HPACK），减少了头部信息的冗余。</p>
<hr>
<h3 id="4-不支持服务器推送"><a href="#4-不支持服务器推送" class="headerlink" title="4. 不支持服务器推送"></a>4. <strong>不支持服务器推送</strong></h3><p><strong>问题</strong>：</p>
<p>​	HTTP&#x2F;1.x不支持服务器主动推送数据，客户端必须通过轮询或长轮询来获取更新，导致实时性差，增加了客户端的负担。</p>
<p><strong>改进</strong>：</p>
<p>​	HTTP&#x2F;2支持服务器推送（Server Push），服务器可以主动向客户端推送资源。</p>
<p><strong>附：</strong><br>        轮询：客户端每隔一段时间向服务器发送http请求，服务器在收到请求后不论是否有数据更新，都直接	进行响应。</p>
<p>​		长轮询：客户端向服务器发起请求，如果服务器没有数据更新，就把请求挂住，直到服务端的数据发生	了更新，或者超时便会返回。</p>
<hr>
<h3 id="5-性能问题"><a href="#5-性能问题" class="headerlink" title="5. 性能问题"></a>5. <strong>性能问题</strong></h3><p><strong>问题</strong>：</p>
<p>​	<strong>短连接</strong>：HTTP&#x2F;1.0默认是短连接的，每次请求都需要重新建立和关闭连接，增加了延迟和资源消耗。</p>
<p>​	<strong>队头阻塞</strong>：HTTP&#x2F;1.1虽然支持持久连接，但仍然存在队头阻塞问题（一个请求的延迟会影响后续请求）。</p>
<p><strong>改进</strong>：</p>
<p>​	使用HTTP&#x2F;2的多路复用技术，允许在同一个连接上同时发送多个请求和接收多个响应。</p>
<p>​	使用HTTP&#x2F;3的QUIC协议，进一步优化性能。</p>
<hr>
<p>​	除了上面这么多，http还有很多不足，比如缺乏优先级，不支持二进制传输，存在跨域限制等问题。</p>
<p>为了解决http的部分不足，便引入了新的协议，其名为WebSocket。</p>
<hr>
<h1 id="2-WebSocket"><a href="#2-WebSocket" class="headerlink" title="2. WebSocket"></a>2. WebSocket</h1><h2 id="2-1-WebSocket"><a href="#2-1-WebSocket" class="headerlink" title="2.1 WebSocket"></a>2.1 WebSocket</h2><p>​	<strong>WebSocket</strong> 是一种在单个TCP连接上进行<strong>全双工通信</strong>的协议，允许客户端和服务器之间进行实时、双向的数据传输。它是HTML5规范的一部分，旨在解决HTTP协议在实时通信中的局限性。</p>
<p><strong>附：</strong>数据只能单向传送为<strong>单工</strong>；<br>    数据能双向传送但不能同时双向传送称为<strong>半双工</strong>；<br>    数据能够同时双向传送则称为<strong>全双工</strong>。</p>
<h2 id="2-2-WebSocket的优点"><a href="#2-2-WebSocket的优点" class="headerlink" title="2.2 WebSocket的优点"></a>2.2 WebSocket的优点</h2><p><strong>WebSocket的优势包括：</strong></p>
<ul>
<li><strong>实时性：</strong> 由于WebSocket的持久化连接，它可以实现实时的数据传输，避免了Web应用程序需要不断地发送请求以获取最新数据的情况。</li>
<li><strong>双向通信：</strong> WebSocket协议支持双向通信，这意味着服务器可以主动向客户端发送数据，而不需要客户端发送请求。</li>
<li><strong>减少网络负载：</strong> 由于WebSocket的持久化连接，它可以减少HTTP请求的数量，从而减少了网络负载。</li>
</ul>
<h2 id="2-3WebSocket的工作过程"><a href="#2-3WebSocket的工作过程" class="headerlink" title="2.3WebSocket的工作过程"></a>2.3WebSocket的工作过程</h2><p>​	WebSocket 生命周期描述了 WebSocket 连接从创建到关闭的过程。一个 WebSocket 连接包含以下四个主要阶段：</p>
<h4 id="连接建立阶段："><a href="#连接建立阶段：" class="headerlink" title="连接建立阶段："></a><strong>连接建立阶段：</strong></h4><p>​	在连接建立阶段，客户端会基于http协议向客户端发送一个特殊的http（get）请求，之所以特殊，是因为其请求头包含了一些特殊的字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /chat HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Origin: http://example.com</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Upgrade:websocket</code>   表示客户端希望协议升级为WebSocket</li>
<li><code>Connection:Upgrade</code>  进一步确认客户端请求协议升级的意图</li>
<li><code>Sec-WebSocket-Key</code> 一个由客户端生成的Base64编码的随机密钥，用于安全认证</li>
<li><code>Sec-WebSocket-Version</code> 用于指定客户端支持的WebSocket版本</li>
<li><code>Origin</code>：指定请求的来源，服务器用于检查请求是否来自合法的域。</li>
</ul>
<p>​	服务器接受到请求后，会对头部字段进行验证。如果验证通过，就会返回一个带有101 Switching Protocols的http响应，表示同意协议升级。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line"></span><br><span class="line">Upgrade: websocket</span><br><span class="line"></span><br><span class="line">Connection: Upgrade</span><br><span class="line"></span><br><span class="line">Sec-WebSocket-Accept: x3JJHMbDL1EzLkh9tC9r0L4BvC6iXgkzB3wIFfEKf4k=</span><br></pre></td></tr></table></figure>

<ul>
<li><code>101 Switching Protocols</code>：表示服务器同意将协议升级。</li>
<li><code>Sec-WebSocket-Accept</code>：服务器通过 <code>Sec-WebSocket-Key</code> 和一个特定的算法计算出一个值并返回，这个值是用来验证客户端发起的握手是否合法。</li>
</ul>
<h4 id="连接开放阶段："><a href="#连接开放阶段：" class="headerlink" title="连接开放阶段："></a><strong>连接开放阶段：</strong></h4><p>​	连接建立后，客户端和服务端便可以通过WebSocket进行双向的数据传输。数据以帧（就是数据链路层的那个）的形式进行传输。帧有许多种类型，比如文本帧（传输文本数据），二进制帧（传输二进制数据，比如图片，音频等），ping帧（用于心跳检测），关闭帧（用于关闭连接）。</p>
<h4 id="连接关闭阶段："><a href="#连接关闭阶段：" class="headerlink" title="连接关闭阶段："></a><strong>连接关闭阶段：</strong></h4><p>​	如果此时客户端或者服务端需要关闭一个WebSocket连接，便会发送一个关闭帧。关闭帧包含一个状态码和可选的关闭原因，用于对方关闭连接的原因。另一方收到关闭帧后，会响应一个关闭帧，并关闭连接。这样的关闭方式可以保证连接正常终止，避免数据丢失或连接异常。</p>
<h4 id="连接关闭完成阶段："><a href="#连接关闭完成阶段：" class="headerlink" title="连接关闭完成阶段："></a><strong>连接关闭完成阶段：</strong></h4><p>​	 在这个阶段，WebSocket 连接已经完全关闭。客户端和服务器之间的任何交互都将无效。</p>
<p>如图：</p>
<p><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.zVPHvJOfM7m8jlks8SFpHwAAAA?rs=1&pid=ImgDetMain" alt="示例图片"></p>
<p>引用自伟大的🫚圣：</p>
<p><a target="_blank" rel="noopener" href="https://vcnay0rphntt.feishu.cn/wiki/DUmLwwac3ipERmkrwjVckSQQn8d?fromScene=spaceOverview">‍‬‌‌﻿⁠﻿‍﻿⁠﻿﻿‌‌‌‍⁠﻿﻿⁠⁠⁠‍‍‌‌‍﻿﻿‌2-8 WebSocket的底层逻辑 - 飞书云文档</a></p>
<h2 id="2-4-WebSocket的API"><a href="#2-4-WebSocket的API" class="headerlink" title="2.4 WebSocket的API"></a>2.4 WebSocket的API</h2><p>​	WebSocket API 是用于在 Web 应用程序中创建和管理 WebSocket 连接的接口集合。WebSocket API 由浏览器原生支持，无需使用额外的 JavaScript 库或框架，可以直接在 JavaScript 中使用。</p>
<p>下面是一些常用的 WebSocket API：</p>
<p>​	<strong>WebSocket 构造函数：</strong> WebSocket 构造函数用于创建 WebSocket 对象。它接受一个 URL 作为参数，表示要连接的 WebSocket 服务器的地址。例如：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">&#x27;ws://example.com/ws&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>WebSocket.send() 方法：</strong> <code>WebSocket.send()</code> 方法用于向服务器发送数据。它接受一个参数，表示要发送的数据。数据可以是字符串、Blob 对象或 ArrayBuffer 对象（常用于处理二进制）。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws.send(&#x27;Hello, server!&#x27;);</span><br></pre></td></tr></table></figure>

<p>​	<strong>WebSocket.onopen 事件：</strong> <code>WebSocket.onopen</code> 事件在 WebSocket 连接成功建立时触发。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WebSocket 连接已经建立。&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	<strong>WebSocket.onmessage 事件：</strong> <code>WebSocket.onmessage</code> 事件在接收到服务器发送的消息时触发。它的 event 对象包含一个 data 属性，表示接收到的数据。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;收到服务器消息：&#x27;</span>, event.<span class="property">data</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	<strong>WebSocket.onerror 事件：</strong> <code>WebSocket.onerror</code> 事件在 WebSocket 连接出现错误时触发。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;WebSocket 连接出现错误：&#x27;</span>, event);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>WebSocket.onclose 事件：</strong> <code>WebSocket.onclose</code> 事件在 WebSocket 连接被关闭时触发。例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.onclose = function() &#123;</span><br><span class="line">  console.log(&#x27;WebSocket 连接已经关闭。&#x27;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上是一些常用的 WebSocket API。</p>
<h2 id="2-5-WebSocket的不足"><a href="#2-5-WebSocket的不足" class="headerlink" title="2.5 WebSocket的不足"></a>2.5 WebSocket的不足</h2><ul>
<li><strong>需要浏览器和服务器都支持：</strong> WebSocket是一种相对新的技术，需要浏览器和服务器都支持。一些旧的浏览器和服务器可能不支持WebSocket。</li>
<li><strong>需要额外的开销：</strong> WebSocket需要在服务器上维护长时间的连接，这需要额外的开销，包括内存和CPU。</li>
<li><strong>安全问题：</strong> 由于WebSocket允许服务器主动向客户端发送数据，可能会存在安全问题。服务器必须保证只向合法的客户端发送数据。</li>
</ul>
<h2 id="2-6-WebSokcet的应用场景"><a href="#2-6-WebSokcet的应用场景" class="headerlink" title="2.6 WebSokcet的应用场景"></a>2.6 WebSokcet的应用场景</h2><ul>
<li>游戏应用程序</li>
<li>聊天应用程序</li>
<li>实时股票、外汇、加密货币行情</li>
<li>在线协作编辑</li>
</ul>
<h1 id="附录："><a href="#附录：" class="headerlink" title="附录："></a>附录：</h1><h2 id="Cookie，Session和Token："><a href="#Cookie，Session和Token：" class="headerlink" title="Cookie，Session和Token："></a>Cookie，Session和Token：</h2><h3 id="关于Cookie："><a href="#关于Cookie：" class="headerlink" title="关于Cookie："></a>关于Cookie：</h3><p>​	<strong>Cookie 是存储在客户端浏览器中的小型文本数据</strong>，用于在 HTTP 请求之间保持用户状态。由于 HTTP 协议是无状态的，每次请求都是独立的，服务器无法记住客户端的状态，而 Cookie 可以帮助服务器跟踪用户。每个 Cookie 不能超过 <strong>4KB</strong>，一个站点最多可存储 <strong>300 个 Cookie</strong>，单个域名最多 <strong>20 个 Cookie</strong>。</p>
<p><strong>附：</strong>JS能够通过document.cookie来访问cookie，从而进行身份冒充访问服务器，但是我们可以通过在Set-Cookie响应头设置HttpOnly来禁止documnet.cookie访问cookie。</p>
<p>​	当用户访问网站时，服务器会在http的响应头中通过Set-Cookie设置cookie，客户端收到后，会将其存储到本地，之后，每次用户请求该网站，浏览器都会自动在请求头中携带cookie，服务器也就可以通过cookie来判断身份。</p>
<h3 id="关于Session："><a href="#关于Session：" class="headerlink" title="关于Session："></a>关于Session：</h3><p>​	<strong>Session 是存储在服务器端的用户会话数据</strong>，用于记录用户的状态。由于 Cookie 存储在客户端，容易被篡改，而 Session 存储在服务器端，相对更安全。</p>
<p>​	当用户访问服务器时，服务器创建一个 Session，并生成一个 session_id，然后，服务器返回session_id，并让客户端存储（通常存储在 Cookie），客户端在后续请求时携带 session_id，服务器便会通过session_id来验证身份。</p>
<h3 id="关于Token："><a href="#关于Token：" class="headerlink" title="关于Token："></a>关于Token：</h3><p>​	<strong>Token是一种身份验证机制，基于无状态（Stateless）认证</strong>，不同于 Session，它不需要服务器存储用户信息，而是通过签名机制来验证数据的完整性，<strong>JWT（JSON Web Token）</strong> 是一种常见的 token 格式。</p>
<p>​	用户登录时，服务器会生成token返回给客户端，客户端可以来存储这个token（比如localStorage.setItem()），后续每次请求时，客户端可以在Authorization中携带token来让服务器验证，如果有效，解析用户信息，否则拒绝请求</p>
<p><strong>附：</strong></p>
<p>​	单一token存在一些问题，比如无法安全地延长登陆状态，要么强制用户重新登录，要么一直有效。如果是前者，对于用户体验不太好；如果是后者，一旦token泄露，攻击者可以长期使用。</p>
<p>​	因此，现在大多采用长短token机制。</p>
<p>长短token分为短期token和长token：</p>
<ul>
<li><p>短token有效期较短，通常用于身份验证和授权操作等敏感操作。由于其生命周期较短，即使被盗用，利用时间也有限，从而降低了安全风险。</p>
</li>
<li><p>长token有效期较长，通常用于用户在一段时间内保持登录状态，避免频繁登录。即使其生命周期较长，但由于不直接进行敏感操作，安全风险较低。</p>
</li>
</ul>
<p>​	用户登录时，服务端会生成一个长token和短token给用户，用户请求资源时，短token用于验证身份。如果短token过期，用户可以通过长token来请求一个新的短token，而无需重新登录。</p>
<h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><p>​	Cookie-Session适用于传统的Web应用，前端代码和后端代码在同一个服务器，浏览器直接从后端加载页面，浏览器会自动携带Cookie或Session_id，因为前端和后端是同一个域名，因此通常不支持跨域。</p>
<p>​	Token适用于前后端分离的项目，前端和后端分开，各自运行在独立的服务器，前端通过Ajax&#x2F;Fetch请求后端API，此时存在跨域，浏览器不会自动携带Cookie或Session_id,因此适用Token认证。</p>
<h2 id="https："><a href="#https：" class="headerlink" title="https："></a>https：</h2><h3 id="什么是https："><a href="#什么是https：" class="headerlink" title="什么是https："></a>什么是https：</h3><p>​	https，即超文本安全传输协议，它在HTTP的基础上增加了加密和认证机制，以保护数据的机密性、完整性和真实性。</p>
<p>​	相较于http，https通过TLS修正了http存在的安全问题：</p>
<h3 id="1-加密传输"><a href="#1-加密传输" class="headerlink" title="1. 加密传输"></a>1. <strong>加密传输</strong></h3><ul>
<li><strong>HTTP</strong>：数据以明文形式传输，容易被窃听或篡改。</li>
<li><strong>HTTPS</strong>：通过SSL&#x2F;TLS协议对数据进行加密，确保传输过程中的安全性。</li>
</ul>
<h4 id="加密机制："><a href="#加密机制：" class="headerlink" title="加密机制："></a>加密机制：</h4><h5 id="共享密钥加密："><a href="#共享密钥加密：" class="headerlink" title="共享密钥加密："></a>共享密钥加密：</h5><p>​	加密和解密共用同一个密钥的方式叫做共享密钥加密，也叫做对称密钥加密。在加密时，用户使用一把密钥进行加密，之后将密钥和加密后的数据发送给另一方，用于解密。但问题又来了，任何人只要有密钥就能解密，如果我的通信被监听，密钥不就落入他人之手了吗？所以传输时还得设法安全保管密钥。</p>
<h5 id="公开密钥加密："><a href="#公开密钥加密：" class="headerlink" title="公开密钥加密："></a>公开密钥加密：</h5><p>​	两名用户各有两把钥匙，一把用于加密，是公开的；一把用于解密，是私密的。在加密时，我可以使用对方公开的钥匙加密，然后发送给对方，对方使用自己私密的密钥进行解密，从而保证通信的安全性。但是，公开密钥加密在传输时由于非对称计算较为复杂，导致效率不如前者，不适合传输大量数据。</p>
<h5 id="混合密钥加密："><a href="#混合密钥加密：" class="headerlink" title="混合密钥加密："></a>混合密钥加密：</h5><p>​	顾名思义，融合了前两种方法。具体过程是使用公开钥匙加密安全地交换在共享密钥中要使用的密钥，然后使用共享密钥加密的方式进行通信。</p>
<hr>
<h3 id="2-数据完整性"><a href="#2-数据完整性" class="headerlink" title="2. 数据完整性"></a>2. <strong>数据完整性</strong></h3><ul>
<li><strong>HTTP</strong>：数据在传输过程中可能被篡改，无法保证完整性。</li>
<li><strong>HTTPS</strong>：通过<strong>消息认证码（MAC）</strong>或<strong>数字签名</strong>确保数据的完整性，防止数据被篡改。</li>
</ul>
<h4 id="完整性保护："><a href="#完整性保护：" class="headerlink" title="完整性保护："></a>完整性保护：</h4><h5 id="消息认证码（MAC）"><a href="#消息认证码（MAC）" class="headerlink" title="消息认证码（MAC）"></a>消息认证码（MAC）</h5><p>​	MAC用于验证数据完整性和真实性，确保数据在传输过程中没有被篡改，而且来自可信的发送方。其原理用到了上面的密钥。</p>
<p>​	发送方和接受方共享一个密钥。生成时，发送方使用密钥和哈希算法对数据计算MAC，然后把数据和MAC一起发给接收方，接收方收到数据后，使用相同的密钥和哈希算法计算MAC，如果相同，则数据完整且来自可信的发送方；如果不同，则数据可能被篡改或来自不可信的发送方。</p>
<h5 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h5><p>​	数字签名和MAC大致相同，区别在于数字签名使用的是非对称的公开密钥加密。</p>
<hr>
<h3 id="3-身份认证"><a href="#3-身份认证" class="headerlink" title="3. 身份认证"></a>3. <strong>身份认证</strong></h3><ul>
<li><strong>HTTP</strong>：无法验证服务器的身份，可能存在中间人攻击。</li>
<li><strong>HTTPS</strong>：通过<strong>数字证书</strong>验证服务器的身份，确保客户端与真实的服务器通信。</li>
</ul>
<h4 id="数字证书："><a href="#数字证书：" class="headerlink" title="数字证书："></a>数字证书：</h4><p>​	数字证书是身份认证的核心，它包含了服务器的身份信息和公钥，并由可信的证书颁发机构（CA）签名。</p>
<h5 id="证书颁发机构（CA）"><a href="#证书颁发机构（CA）" class="headerlink" title="证书颁发机构（CA）"></a>证书颁发机构（CA）</h5><p>​	证书颁发机构（CA）是受信任的第三方机构，负责验证服务器的身份并颁发数字证书。</p>
<h5 id="数字证书内容"><a href="#数字证书内容" class="headerlink" title="数字证书内容"></a>数字证书内容</h5><p>​	数字证书通常包含以下信息：</p>
<ul>
<li><strong>服务器的公钥</strong>：用于加密通信。</li>
<li><strong>服务器的域名</strong>：证书绑定的域名（如 <code>www.example.com</code>）。</li>
<li><strong>证书的有效期</strong>：证书的生效日期和过期日期。</li>
<li><strong>颁发机构的信息</strong>：CA 的名称和标识。</li>
<li><strong>颁发机构的数字签名</strong>：CA 对证书内容的签名，用于验证证书的真实性。</li>
</ul>
<h5 id="证书验证流程"><a href="#证书验证流程" class="headerlink" title="证书验证流程"></a><strong>证书验证流程</strong></h5><p>​	首先，服务器在TLS&#x2F;SSL 握手过程中将自己的数字证书发送给客户端。</p>
<p>​	然后，客户端使用 CA 的公钥解密证书中的签名，得到证书的哈希值。</p>
<p>​		    客户端对证书内容计算哈希值，并与解密得到的哈希值进行比较。</p>
<p>​				1. 如果一致，则证书真实可信。</p>
<p>​				2. 如果不一致，则证书可能被篡改或伪造。</p>
<p>​	再然后，客户端检查证书中的域名是否与访问的域名一致。</p>
<p>​				1. 如果一致，则域名验证通过。</p>
<p>​				2. 如果不一致，则可能是域名不匹配或证书被滥用。</p>
<p>​	之后，客户端检查证书是否在有效期内。</p>
<p>​				1. 如果证书在有效期内，则有效期验证通过。</p>
<p>​				2. 如果证书已过期，则客户端会拒绝连接。</p>
<p>​	最后，客户端检查证书是否被吊销（如通过 CRL 或 OCSP）。</p>
<p>​				1. 如果证书未被吊销，则吊销状态验证通过。</p>
<p>​				2. 如果证书已被吊销，则客户端会拒绝连接。</p>
<p>​	所有验证全部通过，通过，通过，通过，通过之后，客户端就成功验证了服务器的身份，可以确认服务器是可信的，并与之建立安全的 HTTPS 连接。</p>
<p><strong>附</strong>：</p>
<p>​	自签名证书是由服务器自己生成并签名的数字证书，而不是由受信任的第三方证书颁发机构签发的。换句话说，服务器既是证书的申请者，也是证书的签发者，就像你向老师交作业自己给自己签字一样。</p>
<hr>
<h2 id="GET和POST："><a href="#GET和POST：" class="headerlink" title="GET和POST："></a>GET和POST：</h2><h3 id="GET与POST的一些区别："><a href="#GET与POST的一些区别：" class="headerlink" title="GET与POST的一些区别："></a>GET与POST的一些区别：</h3><ul>
<li>GET习惯上把客户端的数据通过query string来传输，而POST习惯上通过body来传输。</li>
<li>GET习惯上从服务器获取数据，POST习惯上是客户端给服务器上传数据</li>
<li>GET请求具有幂等性，POST请求不具有幂等性。</li>
<li>GET请求可以被缓存，而POST请求不能被缓存。</li>
</ul>
<h3 id="GET和POST的职能："><a href="#GET和POST的职能：" class="headerlink" title="GET和POST的职能："></a>GET和POST的职能：</h3><p>​	从理论上讲，<strong>GET</strong> 和 <strong>POST</strong> 请求虽然有各自的语义和推荐用途，但在一定条件下，它们的功能是可以<strong>交换的</strong>，即一个请求方法可以用于另一个请求方法的传统功能。</p>
<p>​	理论上，可以通过 GET 请求来提交数据（比如在 URL 中传递参数），这相当于在某些情况下 模拟 POST 请求，甚至可以直接带上body数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;http://example.com/api/test&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">key</span>: <span class="string">&#x27;value&#x27;</span> &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;GET with body:&#x27;</span>, data))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error:&#x27;</span>, error));</span><br></pre></td></tr></table></figure>



<p>​	理论上，你也可以使用 POST 请求来获取数据，例如，使用 POST 请求提交一个查询条件（将条件放在请求体中），服务器根据这些条件返回结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;http://example.com/api/test?param1=value1&amp;param2=value2&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;POST with query string and body:&#x27;</span>, data))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error:&#x27;</span>, error));</span><br></pre></td></tr></table></figure>



<p>​	然而，这些做法通常不符合 HTTP 协议的最佳实践，并且可能带来一些问题和副作用。比如在 GET 请求中包含 body，很多实现会忽略 body 数据，因为body的语义未定义。</p>
<h3 id="关于GET请求的URL长度："><a href="#关于GET请求的URL长度：" class="headerlink" title="关于GET请求的URL长度："></a>关于GET请求的URL长度：</h3><p>​	反正都杂谈了，顺便说点小垃圾只是吧。</p>
<p>​	网上有一种说法是说GET请求的长度存在上限，但实际上RFC 2616或者RFC 2396，都没有具体设定URL的长度上限，之所以实际开发中有上限，是因为浏览器为了确保性能、安全和兼容性对其做出上限；又或者服务器为了防止过长的请求导致资源消耗过大或引发安全问题而限制长度。</p>
<h3 id="关于POST比GET更加安全："><a href="#关于POST比GET更加安全：" class="headerlink" title="关于POST比GET更加安全："></a>关于POST比GET更加安全：</h3><p>​	其实我开始也觉得POST比GET更加安全，因为GET把数据放在query string上，从URL中就能看到用户名和密码了；而POST把数据放在body中，登录时看不到，很安全😋。</p>
<p>​	实际上，通过F12开发者工具或者Fiddler(我还没搞懂，搞懂再水一期😋)一抓包就原形毕露了。</p>
<hr>
<h2 id="Socket-IO"><a href="#Socket-IO" class="headerlink" title="Socket.IO:"></a>Socket.IO:</h2><h3 id="什么是Socket-IO"><a href="#什么是Socket-IO" class="headerlink" title="什么是Socket.IO:"></a>什么是Socket.IO:</h3><p>​	Socket.IO 是一个用于 <strong>实时、双向、基于事件通信</strong> 的 JavaScript 库，适用于浏览器和 Node.js。它在 WebSockets 之上进行了一层封装，并提供了自动降级机制（如 HTTP 长轮询），确保在不同网络环境下都能实现稳定的实时通信。</p>
<h3 id="Socket-IO的优点："><a href="#Socket-IO的优点：" class="headerlink" title="Socket.IO的优点："></a>Socket.IO的优点：</h3><h4 id="兼容性更好"><a href="#兼容性更好" class="headerlink" title="兼容性更好"></a>兼容性更好</h4><p>​	WebSocket 仅适用于 <strong>支持 WebSocket 的浏览器</strong>，而 Socket.IO <strong>可以在所有环境中运行</strong>，即使浏览器不支持 WebSocket，它也会自动降级到 <strong>XHR 轮询</strong> 或 <strong>JSONP 轮询</strong>，保证通信稳定性。</p>
<p><strong>附：</strong></p>
<p><strong>XHR 轮询：</strong>传统的AJAX轮询，每隔一段时间（如 1 秒）向服务器发送请求，检查是否有新消息，但是频繁请求可		     能会增加服务器负担。</p>
<p><strong>JSONP 轮询：</strong>利用<Script>标签绕过浏览器的同源策略，来加载任何域的JS文件。同源”是指网页的 URL 与请求			的资源 URL 在域名、协议或端口全部相同，任意一个不同即为不同源。</p>
<h4 id="断线重连"><a href="#断线重连" class="headerlink" title="断线重连"></a>断线重连</h4><p>​	<strong>WebSocket 断开后不会自动重连</strong>，需要手动编写重连逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">connect</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://localhost:3000&quot;</span>);</span><br><span class="line">    ws.<span class="property">onclose</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(connect, <span class="number">1000</span>); <span class="comment">// 断开后 1 秒后重连</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">connect</span>();</span><br></pre></td></tr></table></figure>

<p>​	<strong>Socket.IO 内置重连机制</strong>，不需要手动处理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> socket = <span class="title function_">io</span>(<span class="string">&quot;http://localhost:3000&quot;</span>, &#123; <span class="attr">reconnection</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">		<span class="comment">//reconnection: true允许客户端在连接失败时自动尝试重连，直到成功或达到最大重试次数。</span></span><br><span class="line">socket.<span class="title function_">on</span>(<span class="string">&quot;connect_error&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;连接失败，正在重试...&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="认证机制："><a href="#认证机制：" class="headerlink" title="认证机制："></a>认证机制：</h4><p>​	WebSocket <strong>本身不提供认证</strong>，但可以通过在URL中添加token进行认证,不过并不安全。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> socket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://example.com/socket?token=your_jwt_token&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>​	相比之下，Socket.IO支持直接auth认证</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> socket = <span class="title function_">io</span>(<span class="string">&quot;http://localhost:3000&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">auth</span>: &#123; <span class="attr">token</span>: <span class="string">&quot;your_jwt_token&quot;</span> &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="房间机制："><a href="#房间机制：" class="headerlink" title="房间机制："></a>房间机制：</h4><p>​	WebSocket <strong>没有房间</strong>概念，所有消息都广播给所有连接的客户端。如果想实现房间功能，需要手动管理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rooms = &#123;&#125;; <span class="comment">// 存储房间成员</span></span><br><span class="line"></span><br><span class="line">ws.<span class="title function_">on</span>(<span class="string">&quot;message&quot;</span>, <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(message);</span><br><span class="line">    <span class="keyword">if</span> (data.<span class="property">type</span> === <span class="string">&quot;join&quot;</span>) &#123;</span><br><span class="line">        rooms[data.<span class="property">room</span>] = rooms[data.<span class="property">room</span>] || [];</span><br><span class="line">        rooms[data.<span class="property">room</span>].<span class="title function_">push</span>(ws);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.<span class="property">type</span> === <span class="string">&quot;message&quot;</span>) &#123;</span><br><span class="line">        rooms[data.<span class="property">room</span>].<span class="title function_">forEach</span>(<span class="function"><span class="params">client</span> =&gt;</span> client.<span class="title function_">send</span>(data.<span class="property">message</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>​	Socket.IO 直接支持 <code>socket.join(&quot;room1&quot;)</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">socket.<span class="title function_">on</span>(<span class="string">&quot;joinRoom&quot;</span>, <span class="function">(<span class="params">room</span>) =&gt;</span> &#123;</span><br><span class="line">    socket.<span class="title function_">join</span>(room);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="事件驱动："><a href="#事件驱动：" class="headerlink" title="事件驱动："></a>事件驱动：</h4><p>​	<strong>事件驱动</strong> 指客户端和服务器<strong>可以定义、监听和触发事件</strong>，实现更灵活的双向通信。</p>
<p>​	但是WebSocket 只能收发文本,需要手动解析 JSON 并区分不同的消息类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ws.<span class="title function_">send</span>(<span class="string">&quot;Hello, Server!&quot;</span>);</span><br><span class="line">ws.<span class="property">onmessage</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;收到消息:&quot;</span>, event.<span class="property">data</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	Socket.IO 支持事件驱动,无需手动解析 JSON,跟axios一样方便</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">socket.<span class="title function_">emit</span>(<span class="string">&quot;chatMessage&quot;</span>, &#123; <span class="attr">user</span>: <span class="string">&quot;Alice&quot;</span>, <span class="attr">message</span>: <span class="string">&quot;Hello!&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">socket.<span class="title function_">on</span>(<span class="string">&quot;chatMessage&quot;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;data.user&#125;</span>: <span class="subst">$&#123;data.message&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Socket-IO的使用："><a href="#Socket-IO的使用：" class="headerlink" title="Socket.IO的使用："></a>Socket.IO的使用：</h3><p>​	这么好的东西，该如何使用呢？很简单。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install socket.io-client</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.socket.io/4.4.1/socket.io.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>引入之后，就可以通过Socket.IO建立WebSocket通信了，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> socket = <span class="title function_">io</span>(<span class="string">&quot;http://localhost:3000&quot;</span>); <span class="comment">//连接服务器</span></span><br><span class="line"></span><br><span class="line">socket.<span class="title function_">on</span>(<span class="string">&quot;message&quot;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;收到服务器消息:&quot;</span>, data);</span><br><span class="line">&#125;) <span class="comment">//监听服务器事件</span></span><br><span class="line"></span><br><span class="line">socket.<span class="title function_">emit</span>(<span class="string">&quot;chatMessage&quot;</span>, <span class="string">&quot;你好，服务器！&quot;</span>)<span class="comment">//发送事件到服务器</span></span><br><span class="line"></span><br><span class="line">socket.<span class="title function_">disconnect</span>()<span class="comment">//断开连接</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://159357254680.github.io/2025/02/18/%E9%97%AD%E5%8C%85,%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/18/%E9%97%AD%E5%8C%85,%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/" class="post-title-link" itemprop="url">闭包，垃圾回收和内存泄露</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-02-18 16:58:10" itemprop="dateCreated datePublished" datetime="2025-02-18T16:58:10+08:00">2025-02-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-02-23 16:08:40" itemprop="dateModified" datetime="2025-02-23T16:08:40+08:00">2025-02-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一-闭包"><a href="#一-闭包" class="headerlink" title="一 . 闭包"></a>一 . 闭包</h1><h2 id="1-什么是闭包："><a href="#1-什么是闭包：" class="headerlink" title="1.什么是闭包："></a>1.什么是闭包：</h2><p>​	什么是闭包？引用<strong>JS</strong>书中的定义，当一个函数能够记住并且访问其所在的作用域，即使这个函数是在作用域之外被执行的，这就是闭包。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span> <span class="comment">// a 是一个被 a 创建的局部变量</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123; <span class="comment">// b 是一个内部函数</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 使用了父函数中声明的变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c = <span class="title function_">a</span>()</span><br><span class="line"><span class="title function_">c</span>() <span class="comment">//1 这就是闭包</span></span><br></pre></td></tr></table></figure>

<p>​	在a() 函数中声明了一个私有变量 a , b() 函数是 a() 函数内部的函数，此时 a 内部的所有局部变量，对 b 都是可见的，但是a()中的变量对于外部是不可见的，b 内部的局部变量，对 a 就是不可见的。这就是JS的”作用域链“。其中，a()在执行之后，将 b 返回，并赋值给了c ，通过c从外部访问了 a() 的内部变量a。</p>
<p>​	闭包是一种保护私有变量的机制，它在函数执行时创建一个私有作用域，从而保护内部的私有变量不受外界干扰,同时允许外界访问内部的私有变量。</p>
<p>​	直观地说，闭包就像是一个不会被销毁的栈环境。</p>
<h2 id="2-闭包的优点："><a href="#2-闭包的优点：" class="headerlink" title="2.闭包的优点："></a>2.闭包的优点：</h2><p>​	从上面的例子可以注意到，a是a()中的一个私有变量，但是我们却在全局作用域中访问了函数的私有变量，从中可以看出了闭包的几个优点：</p>
<ol>
<li><strong>保护私有变量</strong></li>
<li><strong>延长变量寿命</strong></li>
<li><strong>实现变量共享</strong></li>
</ol>
<p>	</p>
<p>为什么这么说呢？可以来看看接下来的几个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span> </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123; </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a) </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c = <span class="title function_">a</span>()</span><br><span class="line"><span class="keyword">const</span> a = <span class="number">2</span> <span class="comment">// 在全局作用域中为a赋值为2</span></span><br><span class="line"><span class="title function_">c</span>() <span class="comment">//最后结果仍然是1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	上述代码中，a是a（）中的一个私有变量，因此外部无法直接访问它。即使在全局声明了一个同名变量a，也无法影响到函数内部，a变量的值只能在函数内部被修改和访问，这样就保护了闭包中的私有变量。</p>
<hr>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> n = <span class="number">0</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(n++)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a++)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add = <span class="title function_">fn</span>()</span><br><span class="line"><span class="title function_">add</span>() <span class="comment">//1 2 </span></span><br><span class="line"><span class="title function_">add</span>() <span class="comment">//1 3 a还活着！</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	一般情况下，在函数<strong>fn</strong>执行完后，就应该连同它里面的变量一同被垃圾回收，但是在这个例子中，<strong>f1（）</strong>函数作为fn的返回值被赋值给了<strong>add</strong>，这时候相当于<strong>add&#x3D;function f1(){ … }<strong>，并且</strong>f1()<strong>内部引用着</strong>fn</strong>里的变量<strong>a</strong>，所以变量<strong>a</strong>无法被销毁，而变量n是每次被调用时新创建的，所以每次<strong>f1</strong>执行完后它就把属于自己的变量连同自己一起销毁，但是把<strong>a</strong>保留了下来，实现了延长变量寿命，但这又出现了一个新问题，后面再讲。</p>
<hr>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span> </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123; </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a) </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c = <span class="title function_">a</span>()</span><br><span class="line"><span class="title function_">c</span>() <span class="comment">//1 我从外部访问了私有变量！</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	还是上面的例子，即使<strong>a</strong>是**a()**中的私有变量，但仍然从外部访问了它，这就是变量共享。</p>
<hr>
<h2 id="3-闭包的作用"><a href="#3-闭包的作用" class="headerlink" title="3. 闭包的作用"></a>3. 闭包的作用</h2><h4 id="3-1节流"><a href="#3-1节流" class="headerlink" title="3.1节流"></a>3.1节流</h4><p>​	<strong>节流</strong>是指限制函数的执行频率<strong>，即在一定时间间隔内</strong>最多只执行一次**，即使事件被多次触发。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> lastTime = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">        <span class="keyword">if</span> (now - lastTime &gt;= delay) &#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">            lastTime = now; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> log = <span class="title function_">throttle</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我滚了&quot;</span>), <span class="number">1000</span>);</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;scroll&quot;</span>, log);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-2-防抖"><a href="#3-2-防抖" class="headerlink" title="3.2 防抖"></a>3.2 防抖</h4><p>​	<strong>防抖</strong>是指在事件触发后，<strong>一定时间内不再触发</strong>，才执行函数。</p>
<p>​	如果在等待时间内再次触发，则重新计时。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> input = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;input&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> handleInput = <span class="title function_">debounce</span>(<span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;搜索：&quot;</span> + event.<span class="property">target</span>.<span class="property">value</span>);</span><br><span class="line">&#125;, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">input.<span class="title function_">addEventListener</span>(<span class="string">&quot;input&quot;</span>, handleInput);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-3-函数柯里化"><a href="#3-3-函数柯里化" class="headerlink" title="3.3 函数柯里化"></a>3.3 函数柯里化</h4><p>​	<strong>柯里化 <strong>是指将一个</strong>多参数</strong>函数转换成多个<strong>单参数</strong>函数的调用链。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">curried</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.<span class="property">length</span> &gt;= fn.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...nextArgs</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> curried.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args.<span class="title function_">concat</span>(nextArgs));</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> curriedAdd = <span class="title function_">curry</span>(add);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curriedAdd</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">// 6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curriedAdd</span>(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">// 6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curriedAdd</span>(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-4-模块化"><a href="#3-4-模块化" class="headerlink" title="3.4 模块化"></a>3.4 模块化</h4><p>​	<strong>模块化</strong>是指<strong>将代码拆分成独立的模块，每个模块负责不同的功能</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">CounterModule</span> = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">increment</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Count:&quot;</span>, count);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">decrement</span>: <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">            count--;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Count:&quot;</span>, count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attr">reset</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Reset to 0&quot;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title class_">CounterModule</span>.<span class="title function_">increment</span>(); <span class="comment">// Count: 1</span></span><br><span class="line"><span class="title class_">CounterModule</span>.<span class="title function_">increment</span>(); <span class="comment">// Count: 2</span></span><br><span class="line"><span class="title class_">CounterModule</span>.<span class="title function_">decrement</span>(); <span class="comment">// Count: 1</span></span><br><span class="line"><span class="title class_">CounterModule</span>.<span class="title function_">reset</span>(); <span class="comment">// Reset to 0</span></span><br></pre></td></tr></table></figure>

<hr>
<p>​	现在，再返回前面的问题，为什么fn()中的a被保留下来，而f1()中的n被销毁了呢？这就引出了JS的垃圾回收机制。</p>
<h1 id="二-垃圾回收"><a href="#二-垃圾回收" class="headerlink" title="二 . 垃圾回收"></a>二 . 垃圾回收</h1><h2 id="1-什么是垃圾："><a href="#1-什么是垃圾：" class="headerlink" title="1. 什么是垃圾："></a>1. 什么是垃圾：</h2><p>​	什么是垃圾呢？垃圾是如何定义的呢？</p>
<p>​	很简单，JS中的函数，变量，对象等都需要占用一定的内存，当这些东西不再被使用的时候，就变成了垃圾。</p>
<p>垃圾可以分为以下几类：</p>
<ol>
<li><strong>已经调用完毕的函数作用域及其内部的值</strong></li>
<li><strong>无法被访问到的值</strong></li>
</ol>
<p>​	正如之前所说，<strong>JS</strong>中的所有的变量都会占用内存，当这些变量变成垃圾的时候，如果不进行回收，内存就会被一直占用，随着程序的运行，垃圾也会越来越多，总有一刻，内存会被占满，程序也就无法运行了。</p>
<hr>
<h2 id="2-垃圾回收机制："><a href="#2-垃圾回收机制：" class="headerlink" title="2. 垃圾回收机制："></a>2. 垃圾回收机制：</h2><p>​	首先，根据JS的内存分配机制，基本数据类型保存在固定的占空间中，可以直接通过值进行访问，但是复杂数据类型的大小不固定，所以其会通过引用地址保存在栈空间，而引用的指向保存的值保存在堆空间，通过引用访问，比如函数，对象等。</p>
<p>​	栈内存中的基本数据类型，可以直接通过操作系统来进行处理，但是堆内存中的复杂数据类型的值的大小不确定，这就需要JS的引擎通过垃圾回收机制进行处理。</p>
<h3 id="2-1-可达性："><a href="#2-1-可达性：" class="headerlink" title="2.1 可达性："></a>2.1 可达性：</h3><p>​	在JS中，内存管理的主要概念是可达性，”可达性“值就是那些以某种方式可访问的值，他们被保证存储在内存中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> me = &#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&quot;奶龙&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	在这里，创建了一个全局变量me，它指向了一个对象{name:“奶龙”}，因此这个这个对象是可达的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> me = &#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&quot;奶龙&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">me = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>​	此时，对象{name:“奶龙”}处于不可达的状态，由于无法访问它，垃圾回收器将回收这个数据并释放内存。</p>
<h3 id="2-2-引用计数和标记清除："><a href="#2-2-引用计数和标记清除：" class="headerlink" title="2.2 引用计数和标记清除："></a>2.2 引用计数和标记清除：</h3><p>​	在浏览器的历史上，有两种垃圾回收的方法：</p>
<ul>
<li>标记清除</li>
<li>引用计数</li>
</ul>
<h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>​	引用计数是一种几乎被淘汰的垃圾回收机制，它通过对每个复杂数据类型的变量进行计数，比如：</p>
<ul>
<li>当变量声明并赋值之后，值得引用数为1</li>
<li>当同一个值被赋值给另一个变量时，引用数加1</li>
<li>当保存该值引用的变量被其它值覆盖时，引用数减1</li>
<li>当一个值的引用数变为0时，就表示无法再访问该值，此时垃圾回收机制就会将其清除并回收内存</li>
</ul>
<p>​	看起来很完美，但只是看起来而已，引用计数存在一个严重的缺陷：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">problem</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">const</span> objA = &#123;&#125;</span><br><span class="line">       <span class="keyword">const</span> objB = &#123;&#125;</span><br><span class="line">       objA.<span class="property">a</span> = objB</span><br><span class="line">       objB.<span class="property">b</span> = objA</span><br><span class="line">       </span><br><span class="line">       objA = <span class="literal">null</span></span><br><span class="line">       objB = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	可以看到，虽然没有其他引用指向objA和objB之前分别指向的两个对象，但它们相互引用，导致它们的引用数永远不会为零，也就永远不会被回收了。因此，现代浏览器采用了另一种新的回收机制。</p>
<h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h4><p>​	相对于引用计数，标记清除就简单的多了，无非就是打不打标记的问题，就跟二进制的0和1十分相似，具体步骤如下：</p>
<ul>
<li>垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0</li>
<li>然后从各个根对象开始遍历，把不是垃圾的节点改成1</li>
<li>清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间</li>
<li>最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收</li>
</ul>
<p>​	但是，标记清除算法有一个很大的缺点，就是在清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了 <code>内存碎片</code>，并且由于剩余空闲内存不是一整块，它是由不同大小内存组成的内存列表，这就牵扯出了内存分配的问题，这里不过多介绍。</p>
<p>回过头来，再来解释上面的问题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> n = <span class="number">0</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(n++)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a++)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add = <span class="title function_">fn</span>()</span><br><span class="line"><span class="title function_">add</span>() <span class="comment">//1 2 </span></span><br><span class="line"><span class="title function_">add</span>() <span class="comment">//1 3 我的a还活着！</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><code>fn</code> 执行</strong>：</p>
<ul>
<li>当调用 <code>fn()</code> 时，局部变量 <code>a</code> 被创建并赋值为 <code>1</code>。</li>
<li>然后返回的是内部函数 <code>f1</code>，并且这个函数内部会访问外部的 <code>a</code> 变量。</li>
</ul>
<p><strong>闭包形成</strong>：</p>
<ul>
<li>函数 <code>f1</code> 是一个 <strong>闭包</strong>，它访问了 <code>fn</code> 中的 <code>a</code> 变量。因此，<code>a</code> 被保存在 <code>f1</code> 的作用域中。</li>
<li>这意味着即使 <code>fn</code> 执行完毕，<code>fn</code> 中的 <code>a</code> 变量依然存在于 <code>f1</code> 的 <strong>闭包环境中</strong>，并不会被销毁。</li>
</ul>
<p>**调用 <code>add()</code>**：</p>
<ul>
<li><code>add</code> 是 <code>fn()</code> 的返回值，即 <code>f1</code> 函数。</li>
<li>每次调用 <code>add()</code> 时，<code>f1</code> 执行并访问了闭包中的 <code>a</code> 变量。</li>
<li>尽管 <code>fn</code> 执行完毕，<code>a</code> 变量的作用域并没有被销毁，因为 <code>f1</code>（闭包）仍然在访问它。<strong>闭包让 <code>a</code> 保持在内存中，直到闭包本身不再被引用。</strong></li>
</ul>
<p>省流：</p>
<p><strong>根对象：</strong></p>
<ul>
<li><code>window</code></li>
<li><code>add</code>（全局变量，指向 <code>f1</code>）</li>
</ul>
<p><strong>可达对象：</strong></p>
<ul>
<li><code>add</code> 指向 <code>f1</code></li>
<li><code>f1</code> 通过闭包作用域 <strong>引用了 <code>a</code></strong></li>
<li><code>a</code> 仍然可达</li>
</ul>
<hr>
<h1 id="三-内存泄漏"><a href="#三-内存泄漏" class="headerlink" title="三. 内存泄漏"></a>三. 内存泄漏</h1><h2 id="1-什么是内存泄露"><a href="#1-什么是内存泄露" class="headerlink" title="1.什么是内存泄露"></a>1.什么是内存泄露</h2><p>​	在介绍闭包的时候，我们发现了一个问题，现在再来看看：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> n = <span class="number">0</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(n++)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a++)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add = <span class="title function_">fn</span>()</span><br><span class="line"><span class="title function_">add</span>() <span class="comment">//1 2 </span></span><br><span class="line"><span class="title function_">add</span>() <span class="comment">//1 3 我的a还活着！</span></span><br></pre></td></tr></table></figure>

<p>​	由于我们使用了闭包，因此延长了局部变量a的寿命，使得我们能够在函数执行完毕时访问它，但这样也导致了a会一直存活，无法被回收，这就是内存泄露。</p>
<p>​	<strong>内存泄漏（Memory Leak）是指程序在运行时无法释放不再使用的内存，导致内存逐渐耗尽，甚至造成程序崩溃或性能下降。</strong></p>
<h2 id="2-怎样会引起内存泄露"><a href="#2-怎样会引起内存泄露" class="headerlink" title="2. 怎样会引起内存泄露"></a>2. 怎样会引起内存泄露</h2><h3 id="2-1-闭包"><a href="#2-1-闭包" class="headerlink" title="2.1 闭包"></a>2.1 闭包</h3><p>​	略</p>
<h3 id="2-2-意外的全局变量"><a href="#2-2-意外的全局变量" class="headerlink" title="2.2 意外的全局变量"></a>2.2 意外的全局变量</h3><p>​	全局变量具有非常长的生命周期，一直到页面被关闭，它都会存活着，所以全局变量上的内存一直都不会被回收。</p>
<h3 id="2-3-角落的定时器"><a href="#2-3-角落的定时器" class="headerlink" title="2.3 角落的定时器"></a>2.3 角落的定时器</h3><p>​	定时器是我们经常使用的一个功能，如果我们在某个页面使用了定时器，但在关闭定时器时没有清除定时器的话，定时器还是活着的。换句话说，定时器的生命周期并不挂靠在页面上，如果在当前页面的JS通过定时器注册了某个回调函数，而该回调函数又持有当前页面的某个变量或某个DOM元素，就会导致即使页面销毁，由于定时器持有该页面部分引用而造成页面无法正常回收，导致内存泄漏。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">clearTimeoutExample</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1000000</span>).<span class="title function_">fill</span>(<span class="string">&quot;Large Object&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> timeoutId = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This will be cleared after 1 second.&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">clearTimeoutExample</span>();</span><br></pre></td></tr></table></figure>

<h3 id="2-4-被遗忘的DOM元素"><a href="#2-4-被遗忘的DOM元素" class="headerlink" title="2.4 被遗忘的DOM元素"></a>2.4 被遗忘的DOM元素</h3><p>​	DOM元素的生命周期是取决于是否可以挂载在DOM树上，当从DOM树上移除时，也就可以被销毁移除了。但是，如果某个DOM元素在JS中也持有它的引用时，那么它的生命周期就由JS和是否在DOM树上二者决定了，只有将两个地方都去清理才能正常回收它</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;myElement&quot;</span>&gt;<span class="title class_">Hello</span>, <span class="title class_">World</span>!&lt;/div&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;removeButton&quot;</span>&gt;</span>Remove Element<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">   </span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="keyword">let</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myElement&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;removeButton&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">           <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(element);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">         </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>​	上述代码中，即使我们从DOM树中移除了<code>#myElement</code> 元素，但<code>element</code> 变量仍然持有对 <code>#myElement</code> 的引用，导致内存泄露。</p>
<h2 id="3-如何解决内存泄露"><a href="#3-如何解决内存泄露" class="headerlink" title="3.如何解决内存泄露"></a>3.如何解决内存泄露</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">big</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> bigData = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1000000</span>).<span class="title function_">fill</span>(<span class="string">&quot;big&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(bigData.<span class="property">length</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> createData = <span class="title function_">big</span>();</span><br><span class="line"><span class="comment">// 在不再需要时，手动解除引用</span></span><br><span class="line">createData = <span class="literal">null</span>;  <span class="comment">// 解除闭包对 largeData 的引用，允许垃圾回收</span></span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span> </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a) </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c = <span class="title function_">a</span>()</span><br><span class="line"><span class="title function_">c</span>() <span class="comment">//尽量使用局部变量而非全局变量</span></span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">clearTimeoutExample</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1000000</span>).<span class="title function_">fill</span>(<span class="string">&quot;Large Object&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> timeoutId = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This will be cleared after 1 second.&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在不再需要时清除定时器</span></span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeoutId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">clearTimeoutExample</span>();</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;myElement&quot;</span>&gt;<span class="title class_">Hello</span>, <span class="title class_">World</span>!&lt;/div&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;removeButton&quot;</span>&gt;</span>Remove Element<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  </span><br><span class="line">  &lt;script&gt;</span><br><span class="line">      <span class="comment">// 在JS中持有对DOM元素的引用</span></span><br><span class="line">      <span class="keyword">let</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myElement&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 给按钮绑定事件监听器</span></span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;removeButton&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">          <span class="comment">// 从DOM树中移除元素</span></span><br><span class="line">          <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(element);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 清除对元素的引用，允许垃圾回收</span></span><br><span class="line">          element = <span class="literal">null</span>;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure>

<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://159357254680.github.io/2025/01/21/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E4%B8%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/01/21/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E4%B8%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/" class="post-title-link" itemprop="url">作用域链与执行上下文</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-01-21 17:33:26" itemprop="dateCreated datePublished" datetime="2025-01-21T17:33:26+08:00">2025-01-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-01-25 15:20:34" itemprop="dateModified" datetime="2025-01-25T15:20:34+08:00">2025-01-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-作用域和作用域链"><a href="#1-作用域和作用域链" class="headerlink" title="1. 作用域和作用域链"></a>1. 作用域和作用域链</h1><h2 id="1-1-什么是作用域"><a href="#1-1-什么是作用域" class="headerlink" title="1.1 什么是作用域"></a>1.1 什么是作用域</h2><p>​	根据MDN的定义，作用域是当前的执行上下文（下面在讲），值和表达式在其中“可见”或可被访问。如果一个变量或表达式不在当前的作用域中，那么它是不可用的。作用域也可以堆叠成层次结构，子作用域可以访问父作用域，反过来则不行。</p>
<p>​	简单来说，<strong>作用域就是限制一个变量在程序中的使用范围</strong>。也就是说作用域最大的用处就是隔离变量，不让变量泄露出去，不同作用域下同名变量不会有冲突。</p>
<hr>
<h2 id="1-2-js中的作用域模型"><a href="#1-2-js中的作用域模型" class="headerlink" title="1.2 js中的作用域模型"></a>1.2 js中的作用域模型</h2><p>​	在js中，采用的是词法作用域（在书里看到这个词感觉很高深啊），也称为静态作用域。与之相对应的还有一个动态作用域。</p>
<p>词法作用域：函数的作用域在函数被定义是就决定了</p>
<p>动态作用域：函数的作用域是在函数调用时才决定的</p>
<p>很好理解：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = <span class="number">1</span></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="keyword">const</span> value = <span class="number">2</span></span><br><span class="line">       <span class="title function_">f1</span>()</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f2</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	根据上面的定义，如果是词法作用域，打印的结果就是1；如果是动态作用域，打印的结果就是2.</p>
<hr>
<h2 id="1-3-作用域的分类"><a href="#1-3-作用域的分类" class="headerlink" title="1.3 作用域的分类"></a>1.3 作用域的分类</h2><p>到目前为止，js中作用域分为三类：</p>
<ul>
<li>全局作用域: 在函数外部声明的变量拥有全局作用域，这意味着它们可以在代码的任何地方被访问。</li>
<li>函数作用域: 在函数内部声明的变量只能在该函数内部被访问，这些变量对于函数外部是不可见的。</li>
<li>块级作用域: 由let和const声明的变量在它们所在的代码块（例如if语句或for循环）内有效，而在代码块外部则无法访问。</li>
</ul>
<p>​	前两种作用域很好理解，用的也很多，这里笔者就不再阐释。不过关于块级作用域在书里则有一些有意思的点：除了上面的let和const，js还有其他与块级作用域相关的功能。</p>
<h3 id="1-3-1-with"><a href="#1-3-1-with" class="headerlink" title="1.3.1 with"></a>1.3.1 with</h3><p>​	虽然with现在已经几乎不被支持，不过它确实是块级作用域的一种形式，用with从对象中创建出的作用域仅在with声明中而非外部作用域中有效</p>
<h3 id="1-3-2-try-catch"><a href="#1-3-2-try-catch" class="headerlink" title="1.3.2 try&#x2F;catch"></a>1.3.2 try&#x2F;catch</h3><p>​	try&#x2F;catch的分句会创建一个块级作用域，其中声明的变量仅在catch中有效。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;<span class="keyword">throw</span> <span class="number">2</span>;&#125;<span class="keyword">catch</span>(a)&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">//2</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="1-4-作用域链"><a href="#1-4-作用域链" class="headerlink" title="1.4 作用域链"></a>1.4 作用域链</h2><p>​	简单来说，由多个执行上下文的变量对象构成的链表就叫作用域链。作用域链主要是进行标识符（在js中所有我们可以自主命名的都可以称之为 标识符，比如变量名和函数名）的查询，标识符解析就是沿着作用域链一级一级的搜索标识符的过程，而作用域链就是保证对变量和函数的有序访问。</p>
<p>在查找一个变量时，通常会进行以下步骤：</p>
<ul>
<li><p>从当前上下文的变量对象中查找</p>
</li>
<li><p>如果没有找到，就会从父级执行上下文的变量对象中查找</p>
</li>
<li><p>如果还是没有找到，就一直找直到全局上下文的变量对象，也就是全局对象，这就到了作用域链的顶端</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> b = a;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 输出 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 报错：b is not defined</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	在这个例子中，变量b在函数foo内部声明，它的作用域链包括函数foo和全局作用域。由于b在函数foo内部找不到定义，所以会向全局作用域查找，找到变量a，因此b的值为1。</p>
</li>
</ul>
<h2 id="1-5作用域嵌套"><a href="#1-5作用域嵌套" class="headerlink" title="1.5作用域嵌套"></a>1.5作用域嵌套</h2><p>​	就像函数可以嵌套一样，作用域也可以多个嵌套，而作用域嵌套遵循以下的规则：</p>
<ul>
<li>内部作用域能够访问外部作用域。</li>
<li>外部作用域无法访问内部作用域。</li>
<li>兄弟作用域不可互相访问。</li>
</ul>
<h1 id="2-执行上下文"><a href="#2-执行上下文" class="headerlink" title="2 执行上下文"></a>2 执行上下文</h1><h2 id="2-1-什么是执行上下文"><a href="#2-1-什么是执行上下文" class="headerlink" title="2.1 什么是执行上下文"></a>2.1 什么是执行上下文</h2><p>​	什么是执行上下文？当一个函数执行时，会创建一个被称为执行上下文的内部对象，这就像一份记录，记录了函数在哪里被调用，函数的调用方式，传入的参数等信息，一个执行上下文定义了一个函数执行时的环境。简单来说，只要有js代码运行，那么它就一定是运行在执行上下文中。</p>
<p>在js中，执行上下文有三种类型：</p>
<ul>
<li>全局执行上下文：只存在一个，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 <code>window</code>对象（浏览器的情况下），并且设置 <code>this</code> 的值等于这个全局对象。</li>
<li>函数执行上下文：可以存在无数个，当函数被调用时才会被创建，且每次函数被调用时都会创建一个新的执行上下文，它会按定义的顺序（后面再说）执行一系列步骤。</li>
<li>Eval函数执行上下文：指在eval函数中运行的代码，不过不建议使用这个这个函数，故不作讨论。</li>
</ul>
<p>执行上下文的生命周期包括三个阶段：<strong>创建阶段→执行阶段→回收阶段</strong>，笔者这里重点介绍创建阶段。</p>
<p><strong>（1）创建阶段</strong> </p>
<p>在 <code>JavaScript</code> 代码执行前，执行上下文将经历创建阶段。在创建阶段会发生三件事：</p>
<ol>
<li>创建<strong>词法环境</strong>组件（后面再说）</li>
<li>创建<strong>变量环境</strong>组件 （后面再说）</li>
<li>this绑定</li>
</ol>
<p><strong>（2）执行阶段</strong></p>
<p>执行变量赋值、代码执行</p>
<p><strong>（3）回收阶段</strong></p>
<p>执行上下文出栈等待被回收</p>
<h2 id="2-2-执行栈"><a href="#2-2-执行栈" class="headerlink" title="2.2 执行栈"></a>2.2 执行栈</h2><p>​	执行栈，又称为调用栈，用于存储代码执行期间创建的所有执行上下文，遵循后进先出的原则。</p>
<p>​	当 Js 引擎第一次遇到我们写的代码时，它会创建一个<strong>全局执行上下文</strong>并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个<strong>新的函数执行上下</strong>文并压入栈的顶部。</p>
<p>​	引擎会优先执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。</p>
<h2 id="2-3-如何管理执行栈"><a href="#2-3-如何管理执行栈" class="headerlink" title="2.3 如何管理执行栈"></a>2.3 如何管理执行栈</h2><p>​	为了解释执行上下文的行为，可以将其以代码的形式阐述。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Stack</span> = [] <span class="comment">//假设这是执行栈，执行栈会先压入全局执行上下文</span></span><br><span class="line">   <span class="title class_">Stack</span>.<span class="title function_">push</span>(<span class="string">&#x27;全局作用域&#x27;</span>)</span><br><span class="line">   </span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;全局作用域&#x27;</span>)<span class="comment">//在全局执行上下文中，js会先执行全局代码，直到遇到一个函数调用								 </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="title function_">f2</span>()</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;函数作用域&#x27;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title function_">f1</span>()<span class="comment">//这里遇到函数调用f1(),它是在全局执行上下文中被调用，因此在全局执行上下文的上方为f1加上一个函数执行上下文</span></span><br><span class="line"><span class="title class_">Stack</span>.<span class="title function_">push</span>(f1)</span><br><span class="line">	<span class="comment">//在f1中又调用了f2，因此在f1的函数执行上下文的上方为f2创建一个函数执行上下文</span></span><br><span class="line"><span class="title class_">Stack</span>.<span class="title function_">push</span>(f2)</span><br><span class="line"></span><br><span class="line"><span class="comment">//遵循后进先出，先执行顶端的f2</span></span><br><span class="line"><span class="title class_">Stack</span>.<span class="title function_">pop</span>()<span class="comment">//f2执行完毕，将其移除</span></span><br><span class="line"><span class="title class_">Stack</span>.<span class="title function_">pop</span>()<span class="comment">//f1执行完毕，将其移除</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	当上述代码在浏览器加载时，js 引擎创建了一个全局执行上下文并把它压入当前执行栈。当遇到 f1（）函数调用时，js 引擎为该函数创建一个新的执行上下文并把它压入当前执行栈的顶部。</p>
<p>​	当从 <code>f1()</code> 函数内部调用 <code>f2()</code> 函数时，js 引擎为 <code>f2()</code> 函数创建了一个新的执行上下文并把它压入当前执行栈的顶部。当 <code>f2()</code> 函数执行完毕，它的执行上下文会从当前栈弹出，并且控制流程到达下一个执行上下文，即 <code>f1()</code> 函数的执行上下文。</p>
<p>​	当 <code>f1()</code> 执行完毕，它的执行上下文从栈弹出，控制流程到达全局执行上下文。一旦所有代码执行完毕，JavaScript 引擎从当前栈中移除全局执行上下文。</p>
<hr>
<h2 id="2-4-初始阶段"><a href="#2-4-初始阶段" class="headerlink" title="2.4 初始阶段"></a>2.4 初始阶段</h2><h3 id="2-4-1-词法环境"><a href="#2-4-1-词法环境" class="headerlink" title="2.4.1 词法环境"></a>2.4.1 词法环境</h3><p>​	根据GPT所言，<strong>词法环境</strong> 是 JavaScript 执行上下文中的一个重要组成部分，用来管理 <code>let</code>、<code>const</code> 声明的变量和函数声明。它是基于代码中的<strong>词法作用域</strong>来定义的，也就是说，变量的可访问性是由它们在代码中的<strong>书写位置</strong>决定的。</p>
<p>​	在词法环境的<strong>内部</strong>有两个组件：</p>
<ul>
<li><p><strong>环境记录器</strong>：是存储变量和函数声明的实际位置。</p>
</li>
<li><p><strong>外部环境的引用</strong>：意味着它可以访问其父级词法环境。</p>
</li>
</ul>
<p>​	<strong>词法环境</strong>有两种类型：</p>
<ul>
<li><strong>全局环境</strong>（在全局执行上下文中）是没有外部环境引用的词法环境。全局环境的外部环境引用是 <strong>null</strong>。它拥有内建的 <code>Object/Array</code>等、在环境记录器内的原型函数（关联全局对象，比如 <code>window</code> 对象）还有任何用户定义的全局变量，并且 <code>this</code>的值指向全局对象。</li>
<li>在<strong>函数环境</strong>中，函数内部用户定义的变量存储在<strong>环境记录器</strong>中。并且引用的外部环境可能是全局环境，或者任何包含此内部函数的外部函数。</li>
</ul>
<h3 id="2-4-2-变量环境"><a href="#2-4-2-变量环境" class="headerlink" title="2.4.2 变量环境"></a>2.4.2 变量环境</h3><p>​	变量环境同样是一个词法环境，其环境记录器持有<strong>变量声明语句</strong>在执行上下文中创建的绑定关系。如上所述，变量环境也是一个词法环境，所以它有着上面定义的词法环境的所有属性。</p>
<p>​	在 ES6 中，<strong>词法环境</strong>组件和<strong>变量环境</strong>组件的一个不同就是前者被用来存储<strong>函数声明</strong>和变量（<code>let</code> 和 <code>const</code>）绑定，而后者只用来存储 <code>var</code> 变量绑定。</p>
<h3 id="2-4-3-this绑定"><a href="#2-4-3-this绑定" class="headerlink" title="2.4.3 this绑定"></a>2.4.3 this绑定</h3><p>​	在全局执行上下文中，<code>this</code> 的值指向全局对象。(在浏览器中，<code>this</code>引用 <code>Window</code> 对象)。 在函数执行上下文中，大多数情况下，<code>this</code> 的值取决于该函数是如何被调用的。如果它被一个引用对象调用，那么 <code>this</code> 会被设置成那个对象，否则 <code>this</code> 的值被设置为全局对象或者 <code>undefined</code>（在严格模式下）。</p>
<hr>
<h2 id="程序执行全过程"><a href="#程序执行全过程" class="headerlink" title="程序执行全过程"></a>程序执行全过程</h2><p>​	程序启动，全局执行上下文被创建，压入执行栈</p>
<ol>
<li>创建全局上下文的 <strong>词法环境</strong><ol>
<li>创建 <strong>对象环境记录器</strong> ，它用来定义出现在 <strong>全局上下文</strong> 中的变量和函数的关系（负责处理 <code>let</code> 和 <code>const</code> 定义的变量）</li>
<li>创建 <strong>外部环境引用</strong>，值为 <strong><code>null</code></strong></li>
</ol>
</li>
<li>创建全局上下文的 <strong>变量环境</strong><ol>
<li>创建 <strong>对象环境记录器</strong>，它持有 <strong>变量声明语句</strong> 在执行上下文中创建的绑定关系（负责处理 <code>var</code> 定义的变量，初始值为 <code>undefined</code> 造成声明提升）</li>
<li>创建 <strong>外部环境引用</strong>，值为 <strong><code>null</code></strong></li>
</ol>
</li>
<li>确定 <code>this</code> 值为全局对象（以浏览器为例，就是 <code>window</code> ）</li>
</ol>
<p>函数被调用，函数执行上下文被创建，压入执行栈</p>
<ol>
<li>创建函数上下文的 <strong>词法环境</strong><ol>
<li>创建 <strong>声明式环境记录器</strong> ，存储变量、函数和参数，它包含了一个传递给函数的 <strong><code>arguments</code></strong> 对象（此对象存储索引和参数的映射）和传递给函数的参数的 <strong>length</strong>。（负责处理 <code>let</code> 和 <code>const</code> 定义的变量）</li>
<li>创建 <strong>外部环境引用</strong>，值为全局对象，或者为父级词法环境（作用域）</li>
</ol>
</li>
<li>创建函数上下文的 <strong>变量环境</strong><ol>
<li>创建 <strong>声明式环境记录器</strong> ，存储变量、函数和参数，它包含了一个传递给函数的 <strong><code>arguments</code></strong> 对象（此对象存储索引和参数的映射）和传递给函数的参数的 <strong>length</strong>。（负责处理 <code>var</code> 定义的变量，初始值为 <code>undefined</code> 造成声明提升）</li>
<li>创建 <strong>外部环境引用</strong>，值为全局对象，或者为父级词法环境（作用域）</li>
</ol>
</li>
<li>确定 <code>this</code> 值</li>
</ol>
<p>进入函数执行上下文的执行阶段：</p>
<p>​	在上下文中运行&#x2F;解释函数代码，并在代码逐行执行时分配变量值。</p>
<p>进入函数执行上下文的回收阶段：</p>
<p>​	将上下文移出执行栈，等待回收。</p>
<p>重复上述步骤直到全局执行上下文移出执行栈。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>​	js解释阶段便会确定作用域规则，因此<strong>作用域在函数定义时就已经确定了</strong>，而不是在函数调用时确定，但是<strong>执行上下文是函数执行之前创建的</strong>。执行上下文最明显的就是this的指向是执行时确定的。而作用域访问的变量是编写代码的结构确定的。</p>
<p>​	作用域和执行上下文之间最大的区别是： <strong>执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变</strong>。</p>
<p>​	一个作用域下可能包含若干个上下文环境。有可能从来没有过上下文环境（函数从来就没有被调用过）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了；有可能同时存在一个或多个闭包（感觉下次可以讲一下，如果没人讲的话）。<strong>同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值</strong>。</p>
<p>最后，简要概况一下<code>作用域</code>，<code>词法环境</code>，<code>执行上下文</code>这三者的概念：</p>
<ul>
<li><strong>作用域</strong>：作用域就是一个独立的区域，它可以让变量不会向外暴露出去。作用域最大的用处就是隔离变量。内层作用域可以访问外层作用域。一个作用域下可能包含若干个执行上下文。</li>
<li><strong>词法环境</strong>：指相应代码块内标识符与变量值、函数值之间的关联关系的一种体现。词法环境内部包含环境记录器和对外部环境的引用。环境记录器是存储变量和函数声明的实际位置，对外部环境的引用意味着可以访问父级词法环境。</li>
<li><strong>执行上下文</strong>：JavaScript代码运行的环境。分为全局执行上下文，函数执行上下文和eval函数执行上下文（前两个较常见）。创建执行上下文时会进行this绑定、创建词法环境和变量环境。</li>
</ul>
<hr>
<p>​	在《JavaScript权威指南》中，有两段有些意思的代码，拿来分享一下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">var</span> scope = <span class="string">&quot;global scope&quot;</span></span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">checkscope</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="keyword">var</span> scope = <span class="string">&quot;local scope&quot;</span></span><br><span class="line">		<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> scope</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_">f</span>()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="title function_">checkscope</span>()</span><br><span class="line">(这是分割线)-------------------------------------------------------------------------------</span><br><span class="line">	<span class="keyword">var</span> scope = <span class="string">&quot;global scope&quot;</span></span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">checkscope</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> scope = <span class="string">&quot;local scope&quot;</span></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> scope</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">return</span> f</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="title function_">checkscope</span>()()</span><br><span class="line">  </span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<p>​	两段代码返回的结果都是“local scope”，看上去好像区别不大，但内部代码在执行时一样吗？</p>
<p>​	事实上，还是有一点区别的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">let</span> <span class="title class_">Stack</span> = [] <span class="comment">//还是用这个模拟一下执行栈</span></span><br><span class="line">    <span class="comment">//模拟第一段代码</span></span><br><span class="line">    <span class="title class_">Stack</span>.<span class="title function_">push</span>(checkscope)</span><br><span class="line">	<span class="title class_">Stack</span>.<span class="title function_">push</span>(f)</span><br><span class="line">	<span class="title class_">Stack</span>.<span class="title function_">pop</span>()</span><br><span class="line">	<span class="title class_">Stack</span>.<span class="title function_">pop</span>()</span><br><span class="line">(这是分割线)-------------------------------------------------------------------------------</span><br><span class="line">    <span class="comment">//模拟第二段代码</span></span><br><span class="line">    <span class="title class_">Stack</span>.<span class="title function_">push</span>(checkscope)</span><br><span class="line">	<span class="title class_">Stack</span>.<span class="title function_">pop</span>()</span><br><span class="line">	<span class="title class_">Stack</span>.<span class="title function_">push</span>(f)</span><br><span class="line">	<span class="title class_">Stack</span>,<span class="title function_">pop</span>()</span><br></pre></td></tr></table></figure>



<h1 id="3-闭包"><a href="#3-闭包" class="headerlink" title="3 闭包"></a>3 闭包</h1><p>新建文件夹</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://159357254680.github.io/2024/12/16/react%20Hooks/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/16/react%20Hooks/" class="post-title-link" itemprop="url">react Hooks</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-12-16 20:45:34" itemprop="dateCreated datePublished" datetime="2024-12-16T20:45:34+08:00">2024-12-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-12-17 16:55:39" itemprop="dateModified" datetime="2024-12-17T16:55:39+08:00">2024-12-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="react-hooks"><a href="#react-hooks" class="headerlink" title="react hooks"></a>react hooks</h1><h2 id="1-什么是Hooks"><a href="#1-什么是Hooks" class="headerlink" title="1.什么是Hooks"></a>1.什么是Hooks</h2><p>​	Hook是一些让你在不使用class的情况下使用state以及其他的react特性的函数。它允许你在函数组件里“钩入”React state等特性。不过，Hook不能再class中使用–你也没必要再使用class。</p>
<h2 id="2-为什么要使用Hooks"><a href="#2-为什么要使用Hooks" class="headerlink" title="2.为什么要使用Hooks"></a>2.为什么要使用Hooks</h2><ul>
<li>Hook允许你在非class的情况下使用更多的React特性。</li>
<li>Hook使你在无需修改组件结构的情况下复用状态逻辑。</li>
<li>Hook将组件中相互关联的部分拆分成更小的函数。</li>
</ul>
<h2 id="3-一些常见的函数"><a href="#3-一些常见的函数" class="headerlink" title="3.一些常见的函数"></a>3.一些常见的函数</h2><h3 id="1-useState"><a href="#1-useState" class="headerlink" title="1.useState"></a>1.useState</h3><p>​		在useState()中，它接受状态的初始值作为参数，并返回一个数组，其中数组的第一项为一个变量，指向状态的当前值，类似于this.state；第二项是一个函数，用来更新状态，类似于setState。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Example</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [count,setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">    	<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        	<span class="tag">&lt;<span class="name">p</span>&gt;</span>你一共点击了&#123;count&#125;下<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    		<span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-useContext"><a href="#2-useContext" class="headerlink" title="2.useContext"></a>2.useContext</h3><p>​		useContext()用于在函数组件中订阅React的上下文。它允许你通过Context.Provider提供的共享数据。说人话，useContext让你能够在组件树中任何位置直接获取上下文数据，而不必通过props一层一层传递。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Context</span> = <span class="title function_">createContext</span>(<span class="string">&#x27;false&#x27;</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [answer,setAnswer] = <span class="title function_">useState</span>(<span class="string">&#x27;false&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">    	<span class="language-xml"><span class="tag">&lt;<span class="name">Context.Provider</span> <span class="attr">value</span>=<span class="string">&#123;answer&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    		<span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        		<span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setAnswer(true)&#125;&gt;点我就对了<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    			<span class="tag">&lt;<span class="name">Example</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    	<span class="tag">&lt;/<span class="name">Context.Provider</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Example</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> answer = <span class="title function_">useContext</span>(<span class="title class_">Context</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">    	<span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我对了吗？&#123;answer&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>首先，你需要使用createContext创建一个上下文对象，这里创建了Context，并提供了默认值’false‘</p>
</li>
<li><p>Context.Provider在组件树中提供了answer的数据。</p>
</li>
<li><p>Example组件通过useContext订阅了Context，并访问当前的answer值。</p>
</li>
</ul>
<p>其中，Context.Provider是上下文系统的核心组件，它用于提供数据给组件树中的下游组件。它接受一个value属性，所有在其内部的组件都能访问到这个value，即使他们不是直接的父子关系。顺带一提，你可以在组件多次调用useContext来访问不同的上下值。</p>
<h3 id="3-useEffect"><a href="#3-useEffect" class="headerlink" title="3.useEffect"></a>3.useEffect</h3><p>​	useEffect()用于处理副作用操作。副作用是指组件渲染过程中，可能会对外部环境产生影响的操作，比如数据获取，订阅事件，操作DOM等。</p>
<p>​	其中，useEffect接受两个参数，一个是副作用函数，另一个是依赖数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span>&#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Example</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [count,setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">	<span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">setCount</span>(count + <span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当没有依赖数组时，useEffect会在组件首次渲染或组件更新时执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span>&#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Example</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [count,setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">	<span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">setCount</span>(count + <span class="number">1</span>)</span><br><span class="line">    &#125;,[])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当传入了空的依赖数组时，useEffect只会在组件首次渲染时执行一次。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span>&#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Example</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [count,setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">	<span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">setCount</span>(count + <span class="number">1</span>)</span><br><span class="line">    &#125;,[count])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当依赖数组中的值存在时，useEffect会在组件首次渲染和依赖数组中的值发生变化时执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">function Example()&#123;</span></span><br><span class="line"><span class="string">    useEffect(() =&gt; &#123;</span></span><br><span class="line"><span class="string">        const timer = setInterval(() =&gt; &#123;</span></span><br><span class="line"><span class="string">        console.log(&#x27;</span>wuhu<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">    &#125;,1000);</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    return() =&gt;&#123;</span></span><br><span class="line"><span class="string">        clearInterval(timer)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">   &#125;,[])</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<p>useEffect可以返回一个清除函数，用于在卸载组件时清除副作用操作，比如取消订阅，清除定时器等。</p>
<h3 id="4-useReducer"><a href="#4-useReducer" class="headerlink" title="4.useReducer"></a>4.useReducer</h3><p>​	useReducer相当于是useState的进阶版。他接受一个形如（state，action）&#x3D;&gt; newState的reducer，并返回当前的state以及预期般配的dispatch方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state,dispatch] = <span class="title function_">useReducer</span>(reducer,initialArg,init);</span><br></pre></td></tr></table></figure>

<p>​	useReducer接受三个参数：</p>
<ul>
<li>reducer</li>
<li>初始化的state。如果没有第三个参数，则state默认是传入的值，返回值为最新的state和dispatch函数。</li>
<li>对初始值state进行一个计算（可以没有）</li>
</ul>
<p>​	useReducer和useState各有千秋，但在state逻辑较复杂且包含多个子值，或者下一个state依赖于之前的state等，useReducer回避useState更加适用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reducer</span> =(<span class="params">state,action</span>) =&gt; &#123;</span><br><span class="line"> 	<span class="keyword">switch</span>(action.<span class="property">type</span>)&#123;</span><br><span class="line"> 		<span class="keyword">case</span><span class="string">&#x27;increment&#x27;</span>:</span><br><span class="line"> 			<span class="keyword">return</span>&#123;<span class="attr">count</span>:state.<span class="property">count</span> + <span class="number">1</span>&#125;;</span><br><span class="line"> 		<span class="keyword">case</span><span class="string">&#x27;decrement&#x27;</span>:</span><br><span class="line"> 			<span class="keyword">return</span>&#123;<span class="attr">count</span>:state.<span class="property">count</span> - <span class="number">1</span>&#125;;</span><br><span class="line"> 		<span class="attr">default</span>:</span><br><span class="line"> 			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Example</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">const</span> [state,dispatch] = <span class="title function_">useReducer</span>(reducer,initialState);</span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">		<span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">			Count:&#123;state.count&#125;</span></span><br><span class="line"><span class="language-xml">			<span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123;type:&#x27;increment&#x27;&#125;)&#125;&gt;+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">			<span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123;type:&#x27;decrement&#x27;&#125;)&#125;&gt;-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;/&gt;</span></span></span><br><span class="line">	)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="5-useRef"><a href="#5-useRef" class="headerlink" title="5.useRef"></a>5.useRef</h3><p>​	useRef()主要用于引用DOM原酸或存储一个可变的值，这个值在整个组件的声明周期保持不变。</p>
<ul>
<li>useRef返回一个可变的ref对象，其内部只有一个current属性被初始化为传入的参数。</li>
<li>useRef返回的ref对象在组件的整个生命周期存在。</li>
<li>更新current的值并不会触发页面的重新渲染。</li>
<li>useRef每次渲染时返回一个ref对象。</li>
</ul>
<h4 id="5-1引用DOM元素"><a href="#5-1引用DOM元素" class="headerlink" title="5.1引用DOM元素"></a>5.1引用DOM元素</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRef,useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inputFocus</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> inputRef = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        inputRef.<span class="property">current</span>.<span class="title function_">focus</span>()</span><br><span class="line">    &#125;,[])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>inputRef是一个ref对象，它的current属性在组件首次渲染时设置为null，在组件被挂载时，inputRefer.current指向实际的inputDOM元素。</p>
<h4 id="5-2存储一个可变的值"><a href="#5-2存储一个可变的值" class="headerlink" title="5.2存储一个可变的值"></a>5.2存储一个可变的值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useRef,useState&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Example</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">const</span> renderCount = <span class="title function_">useRef</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">const</span> [count,setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">const</span> <span class="title function_">increment</span>= (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">		<span class="title function_">setCount</span>(count + <span class="number">1</span>)</span><br><span class="line">		renderCount.<span class="property">current</span>++</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span>(</span><br><span class="line">		<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">			<span class="tag">&lt;<span class="name">p</span>&gt;</span>Render Count: &#123;renderCount.current&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">			<span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">			<span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;increment&#125;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>renderCount是一个ref对象，用来存储渲染次数。每次点击按钮时，increment函数会被调用，count和renderCount的值都会增加。但是，只有count状态的改变会触发组件重新渲染，renderCount.current则不会。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://159357254680.github.io/2024/11/29/%E7%BB%91%E5%AE%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/29/%E7%BB%91%E5%AE%9A/" class="post-title-link" itemprop="url">硬绑定方法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-11-29 20:33:51" itemprop="dateCreated datePublished" datetime="2024-11-29T20:33:51+08:00">2024-11-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-01-25 14:17:35" itemprop="dateModified" datetime="2025-01-25T14:17:35+08:00">2025-01-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​	在JavaScript中，this的指向分为软绑定和硬绑定。其中，在对象调用其内部方法时，this指向它的调用者，这就是软绑定；而硬绑定就需要用到JavaScript的内置方法call&#x2F;aplly&#x2F;bind了实现了。</p>
<h1 id="1-call"><a href="#1-call" class="headerlink" title="1.call"></a>1.call</h1><p>​	call（）方法会将this指向传入的第一个参数，并且可以接受多个参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">who</span>(<span class="params"></span>)&#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>([<span class="variable language_">this</span>.<span class="property">name</span>,<span class="variable language_">this</span>.<span class="property">dialogue</span>]);</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> obj = &#123;</span><br><span class="line">         <span class="attr">name</span>:<span class="string">&#x27;维克托&#x27;</span>,</span><br><span class="line">         <span class="attr">dialogue</span>:<span class="string">&#x27;加入光荣的进化吧&#x27;</span>,</span><br><span class="line">         <span class="attr">who</span>:who</span><br><span class="line">     &#125;</span><br><span class="line">            </span><br><span class="line">     obj.<span class="title function_">who</span>()</span><br><span class="line"><span class="comment">//Window</span></span><br><span class="line"><span class="comment">//[&#x27;维克托&#x27;，&#x27;加入光荣的进化吧&#x27;]</span></span><br><span class="line"><span class="comment">//obj</span></span><br></pre></td></tr></table></figure>

<p>​	可以看到第一次this指向了Window，而第二次指向了调用它的obj。</p>
<p>​	如果我们用call（）方法改变this指向又会怎么样呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">function</span> <span class="title function_">who</span>(<span class="params">a</span>)&#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>([<span class="variable language_">this</span>.<span class="property">name</span>,<span class="variable language_">this</span>.<span class="property">dialogue</span>]);</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> obj = &#123;</span><br><span class="line">         <span class="attr">name</span>:<span class="string">&#x27;维克托&#x27;</span>,</span><br><span class="line">         <span class="attr">dialogue</span>:<span class="string">&#x27;加入光荣的进化吧&#x27;</span>,</span><br><span class="line">         <span class="attr">who</span>:who</span><br><span class="line">     &#125;</span><br><span class="line">            </span><br><span class="line">     <span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;杰斯&#x27;</span>,</span><br><span class="line">        <span class="attr">dialogue</span>:<span class="string">&#x27;为了美好的明天而战&#x27;</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     obj.<span class="property">who</span>.<span class="title function_">call</span>(obj2,<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//[&#x27;杰斯&#x27;,&#x27;为了守护更美好的明天而战&#x27;]</span></span><br><span class="line"><span class="comment">//obj2</span></span><br><span class="line"><span class="comment">//6</span></span><br></pre></td></tr></table></figure>

<p>​	不难看出，this指向又变为了obj2。其中，call（）中，第一个参数是this指向的对象，后面的参数则是传给who（）的。</p>
<h2 id="自己的call（）方法"><a href="#自己的call（）方法" class="headerlink" title="自己的call（）方法"></a>自己的call（）方法</h2><p>​	本人后面又在CSDN上看到了其他作者对自定义call（）方法的理解，觉得很不错，就当补充放上来了😋。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">		 <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span>(<span class="params">context,...args</span>)&#123;</span><br><span class="line">            context = context ? context : <span class="variable language_">window</span><span class="comment">//如果context为null，则this指向Window</span></span><br><span class="line">            context.<span class="property">fn</span> = <span class="variable language_">this</span><span class="comment">//将原函数（this）赋给 context.fn</span></span><br><span class="line">            context.<span class="title function_">fn</span>(...args)<span class="comment">//调用原函数，并传递参数，this 会指向 context</span></span><br><span class="line">            <span class="keyword">delete</span> context.<span class="property">fn</span><span class="comment">//避免浪费内存</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">            <span class="attr">name</span>:<span class="string">&#x27;iso&#x27;</span>，</span><br><span class="line">            <span class="attr">say</span>:<span class="string">&#x27;it is you and me&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">            <span class="attr">name</span>:<span class="string">&#x27;bluejoker&#x27;</span>,</span><br><span class="line">            <span class="attr">say</span>:<span class="keyword">function</span>(<span class="params">...args</span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(args);</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        obj2.<span class="property">say</span>.<span class="title function_">myCall</span>(obj1,obj1.<span class="property">name</span>,obj1.<span class="property">say</span>)</span><br><span class="line"><span class="comment">//[&#x27;iso&#x27;，&#x27;it is you and me&#x27;]</span></span><br><span class="line"><span class="comment">//obj1</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="2-apply"><a href="#2-apply" class="headerlink" title="2.apply"></a>2.apply</h1><p>​	apply()方法会将this指向传入的第一个参数，并接受一个参数数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">            <span class="attr">name</span>:<span class="string">&#x27;iso&#x27;</span>,</span><br><span class="line">            <span class="attr">say</span>:<span class="string">&#x27;it is you and me&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">            <span class="attr">name</span>:<span class="string">&#x27;bluejoker&#x27;</span>,</span><br><span class="line">            <span class="attr">say</span>:<span class="keyword">function</span>(<span class="params">...args</span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(args);</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        obj2.<span class="property">say</span>.<span class="title function_">apply</span>(obj1,[obj1.<span class="property">name</span>,obj1.<span class="property">say</span>])</span><br><span class="line"><span class="comment">//[&#x27;iso&#x27;，&#x27;it is you and me&#x27;]</span></span><br><span class="line"><span class="comment">//obj1</span></span><br></pre></td></tr></table></figure>

<h2 id="自己的apply（）方法"><a href="#自己的apply（）方法" class="headerlink" title="自己的apply（）方法"></a>自己的apply（）方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">	<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span> (<span class="params">context,arr</span>)&#123;</span><br><span class="line">            context = context ? context : <span class="title class_">Window</span><span class="comment">//同上</span></span><br><span class="line">            context.<span class="property">fn</span> = <span class="variable language_">this</span><span class="comment">//同上</span></span><br><span class="line">            <span class="keyword">if</span>(!arr)&#123;</span><br><span class="line">                context.<span class="title function_">fn</span>()<span class="comment">//判断arr是否为空或为null，undefined等，是则立刻调用context.fn()</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr))&#123;<span class="comment">//判断是否为数组</span></span><br><span class="line">                context.<span class="title function_">fn</span>(...arr)<span class="comment">//是则传递参数</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title class_">TypeError</span>(<span class="string">&quot;arr is not a Array&quot;</span>)</span><br><span class="line">            &#125;<span class="comment">//不是则返回异常</span></span><br><span class="line">            <span class="keyword">delete</span> context.<span class="property">fn</span><span class="comment">//同上</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">            <span class="attr">name</span>:<span class="string">&#x27;iso&#x27;</span>,</span><br><span class="line">            <span class="attr">say</span>:<span class="string">&#x27;it is you and me&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">            <span class="attr">name</span>:<span class="string">&#x27;bluejoker&#x27;</span>,</span><br><span class="line">            <span class="attr">say</span>:<span class="keyword">function</span>(<span class="params">...args</span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(args);</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        obj2.<span class="property">say</span>.<span class="title function_">myApply</span>(obj1,[obj1.<span class="property">name</span>,obj1.<span class="property">say</span>])</span><br><span class="line"><span class="comment">//[&#x27;iso&#x27;，&#x27;it is you and me&#x27;]</span></span><br><span class="line"><span class="comment">//obj1</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="3-bind"><a href="#3-bind" class="headerlink" title="3.bind"></a>3.bind</h1><p>​	bind（）方法会将this指向传入的第一个参数，并接受任意形式的参数，同时，bind（）返回一个新的函数。(这个新函数 保留原函数的原型链。这意味着，如果我们用 bind 生成的函数作为构造函数（通过 new 调用），新创建的实例应该能够访问原函数的原型上的方法。)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">       <span class="attr">name</span>:<span class="string">&#x27;Alice&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 普通函数调用</span></span><br><span class="line">   <span class="keyword">const</span> boundSayHello = <span class="title class_">Person</span>.<span class="title function_">bind</span>(obj,obj.<span class="property">name</span>);</span><br><span class="line">   <span class="title function_">boundSayHello</span>(); <span class="comment">// 输出: Alice</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 构造函数调用</span></span><br><span class="line">   <span class="keyword">const</span> <span class="title class_">BoundPerson</span> = <span class="title class_">Person</span>.<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="string">&#x27;Bob&#x27;</span>);</span><br><span class="line">   <span class="keyword">const</span> newPerson = <span class="keyword">new</span> <span class="title class_">BoundPerson</span>();</span><br><span class="line">   newPerson.<span class="title function_">sayHello</span>(); <span class="comment">// 输出: Hello, my name is Bob</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(newPerson <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// 输出: true</span></span><br></pre></td></tr></table></figure>



<h2 id="自己的bind（）方法"><a href="#自己的bind（）方法" class="headerlink" title="自己的bind（）方法"></a>自己的bind（）方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">	<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span>(<span class="params">context,...args</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="variable language_">this</span> !==<span class="string">&quot;function&quot;</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(</span><br><span class="line">                    <span class="string">&quot;this is not a function&quot;</span></span><br><span class="line">                )</span><br><span class="line">            &#125;<span class="comment">//判断this是否指向一个函数，否则抛出错误</span></span><br><span class="line">            <span class="keyword">let</span> self = <span class="variable language_">this</span><span class="comment">//保留原本的this指向，即myBind的调用者</span></span><br><span class="line">            <span class="keyword">let</span> fNOP = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;<span class="comment">//为新绑定的函数（fBound）设置正确的原型链，以确保它继承原函										 数的原型。如果直接赋值fBound.prototype  = this.prototype 									    可能会丢失一些构造函数的特性</span></span><br><span class="line">            <span class="keyword">let</span> fBound = <span class="keyword">function</span> (<span class="params">...bindArgs</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> self.<span class="title function_">apply</span>(</span><br><span class="line">                     <span class="variable language_">this</span> <span class="keyword">instanceof</span> fNOP ? <span class="variable language_">this</span> : context,<span class="comment">//此处 this 指的是 fBound 函数的调用者,这一部分的作用是判断 fBound 是否通过 new 关键字被调用。也就是说，我们检查当前 this 是否是 fNOP 的实例。为什么是 fNOP 呢？因为 fNOP 是一个空函数，我们会通过 new fNOP() 创建一个对象，来模拟 bind 的行为，确保 fBound 被当作构造函数调用时，能够正确地继承原函数的原型。</span></span><br><span class="line"><span class="comment">//如果 fBound 是通过 new 关键字调用的，那么 this 会指向新创建的对象，而不是我们手动传入的 context。</span></span><br><span class="line"><span class="comment">//如果 fBound 是普通函数调用（即没有使用 new），则 this 会指向传入的 context。</span></span><br><span class="line">           			</span><br><span class="line">                    args.<span class="title function_">concat</span>(bindArgs)<span class="comment">//将最初绑定时传入的参数 args 和后续调用 fBound 时传入										的参数 bindArgs 合并，形成完整的参数列表传递给原函数。</span></span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">              fNOP.<span class="property"><span class="keyword">prototype</span></span> = <span class="variable language_">this</span>.<span class="property"><span class="keyword">prototype</span></span><span class="comment">//将 fNOP 的原型指向原函数的原型对象。也就是说，		fNOP 继承了原函数的所有实例方法。这样，fNOP 作为一个空函数，实际上并没有自己的实例方法，但它通过设置 	prototype，让任何通过 new fNOP() 创建的对象都能够访问原函数的原型上的方法。</span></span><br><span class="line">        </span><br><span class="line">            fBound.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">fNOP</span>()<span class="comment">//让 fBound 的原型对象（即 fBound.prototype）指向一个 fNOP 的实例。由于 fNOP 的 prototype 指向了原函数的原型，所以通过 new fNOP() 创建的对象实际上继承了原函数的原型。因此，这样就确保了 fBound 的原型链上有原函数的原型。</span></span><br><span class="line">        </span><br><span class="line">            <span class="keyword">return</span> fBound<span class="comment">//最终，返回的是 fBound 函数，它已经被绑定了 this 上下文和初始参数。当你调								用 fBound 时，它会使用绑定的上下文和参数执行原始函数。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> obj = &#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;Alice&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通函数调用</span></span><br><span class="line">    <span class="keyword">const</span> boundSayHello = <span class="title class_">Person</span>.<span class="title function_">myBind</span>(obj,obj.<span class="property">name</span>);</span><br><span class="line">    <span class="title function_">boundSayHello</span>(); <span class="comment">// 输出: Alice</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 构造函数调用</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">BoundPerson</span> = <span class="title class_">Person</span>.<span class="title function_">myBind</span>(<span class="literal">null</span>, <span class="string">&#x27;Bob&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> newPerson = <span class="keyword">new</span> <span class="title class_">BoundPerson</span>();</span><br><span class="line">    newPerson.<span class="title function_">sayHello</span>(); <span class="comment">// 输出: Hello, my name is Bob</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(newPerson <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// 输出: true</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>​	call、apply、bind 都可以改变 this 的指向，三者第一个参数都是this要指向的对象，如果没有这个参数或参数为undefined或null，则默认指向全局window。但它们略有不同：</p>
<ol>
<li>call能够接受多个参数</li>
<li>apply接受一个数组作为参数</li>
<li>bind能够接受任意类型的参数，并返回一个新的函数</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://159357254680.github.io/2024/11/20/%E8%BF%99%E6%98%AF%E6%A0%87%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/20/%E8%BF%99%E6%98%AF%E6%A0%87%E9%A2%98/" class="post-title-link" itemprop="url">这是标题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-11-20 18:28:39" itemprop="dateCreated datePublished" datetime="2024-11-20T18:28:39+08:00">2024-11-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-12-01 12:49:31" itemprop="dateModified" datetime="2024-12-01T12:49:31+08:00">2024-12-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>第一次写博客，文笔有点烂，也不知道要说些什么，各位见谅一下吧😋</p>
<h1 id="1-js执行机制"><a href="#1-js执行机制" class="headerlink" title="1. js执行机制"></a>1. js执行机制</h1><h2 id="1-1-小谈一下"><a href="#1-1-小谈一下" class="headerlink" title="1.1 小谈一下"></a>1.1 小谈一下</h2><p>​	js是一门单线程语言，执行程序就像在食堂吃饭排队，必须一个一个来。这样看上去充满秩序，但在面对像定时器这样需要等待处理的任务时就会卡住，这就好比你在做饭时需要煮饭洗菜炒菜，而你必须等煮完饭才能去洗菜炒菜，这期间你什么都干不了。这样相当浪费时间，因此js将任务分为了同步和异步两种类型。</p>
<h2 id="1-2-同步"><a href="#1-2-同步" class="headerlink" title="1.2 同步"></a>1.2 同步</h2><p>​	所谓同步，就是发出一个功能调用时，在没有得到结果之前，该调用就不返回或继续执行后续操作。</p>
<p>举个小例子：你是一名CCNU的学生。有一天，你想改善伙食，但无奈捉襟见肘。于是你给你家人打了个电话，只要接通，你就有money拿，但对方没有接通。你不停地打电话，因为没接通就没有生活费，没有生活费就没有豪赤的。最后一天过去了，电话没打通，你只能吃6块钱的营养套餐😡。</p>
<p>​	由此可见，同步的好处在于能够马上得到返回的结果，但必须一个接一个的执行。一旦中间哪步少了或者出错，程序就会卡住，白白浪费时间。</p>
<h2 id="1-3-异步"><a href="#1-3-异步" class="headerlink" title="1.3 异步"></a>1.3 异步</h2><p>​	异步，与同步相对，当一个异步过程调用发出后，在没有得到结果之前，可以继续执行后续操作。</p>
<p>有一个小例子：你是一名CCNU的学生。有一天，你想改善伙食，但无奈捉襟见肘。于是你给你家人发了一条短信，告诉他们你没米了，让他们速速转钱。虽然他们当时在忙没看到，但到了饭点，你还是收到了转账。最后，你happy地吃上了8块钱地营养套餐😋。</p>
<p>​	不难看出，异步虽然返回结果慢一些，但它能够在等待的同时执行后续操作，避免了时间的浪费。</p>
<hr>
<p>​	在执行过程中，js会先执行同步代码，待其全部完毕后，再执行异步代码。</p>
<p>​	看上去好像很对，实际上不对。正如人与人不能一概而论，异步任务之间亦有差别。有些异步任务需要连贯执行，不能分开。</p>
<p>​	想象一下，你在超市买了很多东西，结果在结账时只接了一件，就被别人插队了，还要你重新去排，这不红温😡？为了解决这个问题，异步任务又被分为了宏任务和微任务。</p>
<hr>
<h2 id="1-4-宏任务"><a href="#1-4-宏任务" class="headerlink" title="1.4 宏任务"></a>1.4 宏任务</h2><p>​	很好理解，宏任务指的就是不需要连贯执行的任务，例如setTimeout。</p>
<p>​	它就像你的寒假作业，你可以做一天，躺一天，只要能做完就行（虽然我一般不做）。</p>
<h2 id="1-5-微任务"><a href="#1-5-微任务" class="headerlink" title="1.5 微任务"></a>1.5 微任务</h2><p>​	相对的，微任务指的就是需要连贯执行的任务，例如Promise。</p>
<p>​	它就像你的期末考试，不能考一天，躺一天，你必须连着把它考完，而且期考都在寒假作业前结束。</p>
<hr>
<p>因此，在js实际执行过程中，js会先执行同步代码，遇到异步宏任务则将其放入宏任务队列中，遇到异步微任务则将其放入微任务队列中，此时二者不分优先级。待所有同步代码执行完，再将异步微任务从队列中调入主线程执行。待微任务执行完后，再将异步宏任务从队列中调入主线程执行。</p>
<hr>
<h1 id="2-Promise"><a href="#2-Promise" class="headerlink" title="2. Promise"></a>2. Promise</h1><p>​	刚才好像提到一下Promise，不知道该说点什么，就讲一下Promise吧😊</p>
<h2 id="2-1-回调地狱"><a href="#2-1-回调地狱" class="headerlink" title="2.1 回调地狱"></a>2.1 回调地狱</h2><p>​	在这之前，先讲一下回调函数。当一个函数被当做一个实参传入到另一个函数，并且这个函数在外部函数内被调用，这个被用来完成某些任务的函数，就是回调函数。当一个回调函数嵌套一个回调函数就形成了一个嵌套结构，而嵌套多了就形成了回调地狱</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params">我是<span class="number">1</span></span>)&#123;</span><br><span class="line">       <span class="keyword">function</span>(<span class="params">我是<span class="number">2</span></span>)&#123;</span><br><span class="line">           <span class="keyword">function</span>(<span class="params">我是<span class="number">3</span></span>)&#123;</span><br><span class="line">               <span class="keyword">function</span>(<span class="params">我是<span class="number">4</span></span>)&#123;</span><br><span class="line">                   <span class="keyword">function</span>(<span class="params">我是<span class="number">5</span></span>)&#123;</span><br><span class="line">                       <span class="keyword">function</span>(<span class="params">我是<span class="number">6</span></span>)&#123;</span><br><span class="line">                           <span class="keyword">function</span>(<span class="params">我是<span class="number">7</span></span>)&#123;</span><br><span class="line">                               <span class="keyword">function</span>(<span class="params">我是<span class="number">8</span></span>)&#123;</span><br><span class="line">                                   ...</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>非常好回调，使我的大脑旋转。</p>
<p>为了不让程序员在面对这串代码时一脸懵逼，ES6提出了一种新的解决方案，那就是promise。</p>
<h2 id="2-2-Promise的参数和状态"><a href="#2-2-Promise的参数和状态" class="headerlink" title="2.2 Promise的参数和状态"></a>2.2 Promise的参数和状态</h2><p>​	Promise诞生的目的就是更优雅地书写异步任务 (优雅永不过时)。它是一个构造函数，因此在调用时可以实例化。它接收函数类型的参数，这个参数又接受两个参数，一个是resolve，一个是reject，分别接受成功和失败时的回调。在Promise的内部又有三种状态（state），分别是pending（原始态），fulfilled（成功态）和rejected（失败态）。其中状态只能由pending转为fulfilled或rejected，fulfilled和rejected既不能变回pending，也不能相互转换。</p>
<p>​	举个例子：new Promise是薛定谔的猫，猫活着就是resolve，寄了就是reject。其中pending是既活又寄的叠加态，打开容器后，猫既可以活着变为fulfilled，也可以寄了变为rejected，但是猫的状态已经确定，你不能用两级反转再把猫变回“寄-活叠加态”，也不能用死者苏生从墓地复活猫或是把哈基米变成哈寄米😡。</p>
<h2 id="2-3-Promise的实例方法"><a href="#2-3-Promise的实例方法" class="headerlink" title="2.3 Promise的实例方法"></a>2.3 Promise的实例方法</h2><p>​	Promise实例对象有成功的结果（value）和失败的结果（reason），如果外部代码想要访问这个成功或失败的值，就需要用到Promise的实例方法了。</p>
<h3 id="2-3-1-then"><a href="#2-3-1-then" class="headerlink" title="2.3.1 then"></a>2.3.1 then</h3><p>​	then是Promise的一个实例方法，它能接受最多两个参数—onFulfilled和onRejected，通过它们我们可以拿到成功或失败时的结果，同时返回一个新的Promise实例对象。因为又会返回一个实例对象，因此then支持链式调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">           <span class="title function_">resolve</span>(<span class="string">`6`</span>)</span><br><span class="line">           <span class="title function_">reject</span>(<span class="string">`7`</span>)</span><br><span class="line">       &#125;)</span><br><span class="line"></span><br><span class="line">       promise.<span class="title function_">then</span>(</span><br><span class="line">           <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> value + <span class="string">`6`</span></span><br><span class="line">           &#125;,</span><br><span class="line">           <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> reason + <span class="string">`7`</span></span><br><span class="line">           &#125;</span><br><span class="line">       ).<span class="title function_">then</span>(</span><br><span class="line">           <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">               <span class="variable language_">console</span>.<span class="title function_">log</span>(value); </span><br><span class="line">           &#125;,</span><br><span class="line">           <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">               <span class="variable language_">console</span>.<span class="title function_">log</span>(reason);</span><br><span class="line">           &#125;</span><br><span class="line">       )</span><br><span class="line"><span class="comment">// =&gt; 66</span></span><br></pre></td></tr></table></figure>

<p>​	可以看到then的执行依赖于上一步的结果，如果其中任意一步出错就会使整个程序出错。</p>
<hr>
<p>​	一般来说，我们在执行程序时都会希望他是成功的，因此一步一个reject不仅写起来麻烦，而且看起来也比较麻烦。为了省略reject，我们就用到了Promise的另一种方法。</p>
<h3 id="2-3-2-catch"><a href="#2-3-2-catch" class="headerlink" title="2.3.2 catch"></a>2.3.2 catch</h3><p>​	catch用于在Promise失败或抛出错误时执行某些操作，它只接受一个失败的回调函数作为参数，并返回一个Promise对象。与then相同，catch同样支持链式调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">	 <span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> num = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">11</span>)</span><br><span class="line">            <span class="keyword">if</span>(num &gt; <span class="number">5</span>)&#123;</span><br><span class="line">                <span class="title function_">resolve</span>(<span class="string">`对了`</span>)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="title function_">reject</span>(<span class="string">`错了`</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        promise.<span class="title function_">then</span>(</span><br><span class="line">            <span class="function">(<span class="params">value</span>) =&gt;</span>&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">            &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(error)</span><br><span class="line">            &#125; )</span><br><span class="line"><span class="comment">//当num &gt; 5时</span></span><br><span class="line"><span class="comment">//-&gt; 对了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//否则</span></span><br><span class="line"><span class="comment">//-&gt; Uncaught (in promise) Error: 错了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p>​	到这里，我们已经可以用then处理正确的结果，用catch处理错误或异常的结果。但实际上，有些操作无论结果正确或是失败都得执行。为此，我们又用到了finally方法。</p>
<h3 id="2-3-3-finally"><a href="#2-3-3-finally" class="headerlink" title="2.3.3 finally"></a>2.3.3 finally</h3><p>​	finally会在Promise状态决定时返回一个新的Promise对象，而不在意当前Promise的状态如何。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> num = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">11</span>)</span><br><span class="line">            <span class="keyword">if</span>(num &gt; <span class="number">5</span>)&#123;</span><br><span class="line">                <span class="title function_">resolve</span>(<span class="string">`我对了吗？`</span>)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="title function_">reject</span>(<span class="string">`我错了吗？`</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        promise.<span class="title function_">then</span>(</span><br><span class="line">            <span class="function">(<span class="params">value</span>) =&gt;</span>&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">            &#125;</span><br><span class="line">        ).<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;我错了吗&quot;</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;).<span class="title function_">finally</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`反正我完了`</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p>总结一下这三位</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> num = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">11</span>)</span><br><span class="line">            <span class="keyword">if</span>(num &gt; <span class="number">5</span>)&#123;</span><br><span class="line">                <span class="title function_">resolve</span>(<span class="string">`我是林克`</span>)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="title function_">reject</span>(<span class="string">`没醒`</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        promise.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">                value = <span class="string">`我醒了`</span></span><br><span class="line">                <span class="keyword">return</span> value</span><br><span class="line">        &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span>&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">                value =<span class="string">`我找到了同伴`</span></span><br><span class="line">                <span class="keyword">return</span> value</span><br><span class="line">        &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">                value =<span class="string">`我打倒了反派`</span></span><br><span class="line">                <span class="keyword">return</span> value</span><br><span class="line">        &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">                value = <span class="string">`我找到了圣兽`</span></span><br><span class="line">                <span class="keyword">return</span> value</span><br><span class="line">        &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">                value = <span class="string">`我打倒了盖依,救出了塞尔达`</span></span><br><span class="line">                <span class="keyword">return</span> value</span><br><span class="line">        &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">                </span><br><span class="line">        &#125;).<span class="title function_">finally</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`反正塞尔达又会被抓了`</span>);</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-4-Promise静态方法"><a href="#2-4-Promise静态方法" class="headerlink" title="2.4 Promise静态方法"></a>2.4 Promise静态方法</h2><h3 id="2-4-1-Promise-all"><a href="#2-4-1-Promise-all" class="headerlink" title="2.4.1 Promise.all"></a>2.4.1 Promise.all</h3><p>​	Promise.all接受一个 Promise 可迭代对象作为输入（一般是数组），并返回一个 新的promise对象。当所有输入的 Promise 都被成功时，返回的 Promise 也将被成功（空的也行），并返回一个包含所有成功结果的数组；如果输入的任意一个 Promise 失败，则返回的 Promise 也将失败，并带有第一个失败的原因。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">6</span>)</span><br><span class="line">       <span class="keyword">const</span> promise2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">6</span>)</span><br><span class="line">       <span class="keyword">const</span> promise3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">6</span>)</span><br><span class="line">       <span class="title class_">Promise</span>.<span class="title function_">all</span>([promise1,promise2,promise3]).<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(value))</span><br><span class="line"> <span class="comment">//-&gt;[6,6,6]</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">const</span> promise1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">6</span>)</span><br><span class="line">       <span class="keyword">const</span> promise2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">6</span>)</span><br><span class="line">       <span class="keyword">const</span> promise3 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">`错了`</span>)</span><br><span class="line">       <span class="title class_">Promise</span>.<span class="title function_">all</span>([promise1,promise2,promise3]).<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(value))</span><br><span class="line"> <span class="comment">//-&gt; Uncaught (in promise) 错了</span></span><br></pre></td></tr></table></figure>

<h3 id="2-4-2-Promise-allSettled"><a href="#2-4-2-Promise-allSettled" class="headerlink" title="2.4.2 Promise.allSettled"></a>2.4.2 Promise.allSettled</h3><p>​	Promise.allSettled接受一个 Promise 可迭代对象作为输入（一般是数组），无论输入的Promise对象结果如何，都会返回一个 新的promise对象，并带有一个包含所有结果的对象数组（包括状态）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">		<span class="keyword">const</span> promise1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">`芜`</span>)</span><br><span class="line">        <span class="keyword">const</span> promise2 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">`湖`</span>)</span><br><span class="line">        <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>([promise1,promise2]).<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(value))</span><br><span class="line"><span class="comment">//-&gt; </span></span><br><span class="line">	[</span><br><span class="line">        &#123;<span class="attr">status</span>: <span class="string">&#x27;fulfilled&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;芜&#x27;</span>&#125;</span><br><span class="line">		&#123;<span class="attr">status</span>: <span class="string">&#x27;rejected&#x27;</span>, <span class="attr">reason</span>: <span class="string">&#x27;湖&#x27;</span>&#125;</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>

<h3 id="2-4-3-Promise-any"><a href="#2-4-3-Promise-any" class="headerlink" title="2.4.3 Promise.any"></a>2.4.3 Promise.any</h3><p>​	Promise.all接受一个 Promise 可迭代对象作为输入（一般是数组），并返回一个 新的promise对象。当输入的 Promise 任意一个成功时，返回的 Promise 也将被成功（空的也行），并返回第一个成功的返回值；如果输入的所有 Promise 失败，则返回的 Promise 也将失败，并带有一个失败的原因。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">const</span> promise1 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">const</span> promise2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">`芜湖`</span>)</span><br><span class="line">        <span class="keyword">const</span> promise3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">`湖芜`</span>)</span><br><span class="line">        <span class="title class_">Promise</span>.<span class="title function_">any</span>([promise1, promise2, promise3]).<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(value));</span><br><span class="line"><span class="comment">//-&gt; 芜湖</span></span><br><span class="line">		<span class="keyword">const</span> promise1 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">`错了吗`</span>);</span><br><span class="line">        <span class="keyword">const</span> promise2 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">`错了吧`</span>)</span><br><span class="line">        <span class="keyword">const</span> promise3 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">`应该全错了`</span>)</span><br><span class="line">        <span class="title class_">Promise</span>.<span class="title function_">any</span>([promise1, promise2, promise3]).<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(value));</span><br><span class="line"><span class="comment">//-&gt; Uncaught (in promise) AggregateError: All promises were rejected</span></span><br></pre></td></tr></table></figure>

<h3 id="2-4-4Promise-race"><a href="#2-4-4Promise-race" class="headerlink" title="2.4.4Promise.race"></a>2.4.4Promise.race</h3><p>​	Promise.race接受一个 Promise 可迭代对象作为输入，并返回一个 Promise。这个返回的 promise的状态 会随着第一个 promise 的状态的决定而决定。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">function</span> <span class="title function_">writeHomework</span>(<span class="params">time,action</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="title function_">resolve</span>(action)</span><br><span class="line">                &#125; ,time)</span><br><span class="line">        &#125;)</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">const</span> promise1 = <span class="title function_">writeHomework</span>(<span class="string">`100`</span>,<span class="string">`睡觉`</span>)</span><br><span class="line">       <span class="keyword">const</span> promise2 = <span class="title function_">writeHomework</span>(<span class="string">`10000`</span>,<span class="string">`写作业`</span>)</span><br><span class="line">       <span class="title class_">Promise</span>.<span class="title function_">race</span>([promise1,promise2]).<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(value))</span><br><span class="line"><span class="comment">//-&gt; 睡觉</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">writeHomework</span>(<span class="params">time,action</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="title function_">reject</span>(action)</span><br><span class="line">                &#125; ,time)</span><br><span class="line">        &#125;)</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">const</span> promise1 = <span class="title function_">writeHomework</span>(<span class="string">`100`</span>,<span class="string">`睡觉`</span>)</span><br><span class="line">       <span class="keyword">const</span> promise2 = <span class="title function_">writeHomework</span>(<span class="string">`10000`</span>,<span class="string">`写作业`</span>)</span><br><span class="line">       <span class="title class_">Promise</span>.<span class="title function_">race</span>([promise1,promise2]).<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(value))</span><br><span class="line"><span class="comment">//-&gt; Uncaught (in promise) 睡觉</span></span><br></pre></td></tr></table></figure>

<h3 id="2-4-5-Promise-reject"><a href="#2-4-5-Promise-reject" class="headerlink" title="2.4.5 Promise.reject"></a>2.4.5 Promise.reject</h3><p>Promise.reject会返回一个失败的 Promise 对象,同时将值作为失败的原因。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">`错了`</span>)</span><br><span class="line"><span class="comment">//等于</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> <span class="title function_">reject</span>(<span class="string">`错了`</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">`错了`</span>)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(error === <span class="string">`错了`</span>))</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h3 id="2-4-6-Promise-resolve"><a href="#2-4-6-Promise-resolve" class="headerlink" title="2.4.6 Promise.resolve"></a>2.4.6 Promise.resolve</h3><p>Promise.resolve会将给定的值转换为一个Promise对象。如果该值本身就是一个Promise，就将该Promise返回；如果该值是一个thenable对象(有用then方法的对象)，Promise.resolve将调用其then方法及其两个回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">const</span> promise1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">`芜湖`</span>)</span><br><span class="line">	promise1.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(value))</span><br><span class="line"><span class="comment">//-&gt; 芜湖</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> <span class="title function_">resolve</span>(<span class="number">7777</span>))</span><br><span class="line">    <span class="keyword">const</span> promise2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(promise1)</span><br><span class="line">    promise2.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(value))</span><br><span class="line"><span class="comment">//=&gt; 7777</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> thenable = &#123;</span><br><span class="line">  		<span class="attr">then</span>: <span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    		<span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> promise1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(thenable);</span><br><span class="line">	promise1.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(value))</span><br><span class="line"><span class="comment">//-&gt; 42</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>​	Promise.all 相当于宝可梦中成功集齐八个道馆徽章才能挑战联盟，少一个即为失败。</p>
<p>​	Promise.allSettled 相当于一颗苹果树，不管好坏，只要结苹果就会把结果返回。</p>
<p>​	Promise.any 相当于你期考时写对一点沾边的内容都算你有分，但你一点不对就全错。</p>
<p>​	Promise.race 相当于一场竞赛，第一个到终点的决定结果。</p>
<p>​	Promise.reject 感觉像教材上学过的亚里士多德的名言，返回的全是错的.</p>
<p>​	Promise.resolve 。。。我不知道啊，返回“主 &#x3D;&#x3D;&#x3D; 6”算了</p>
<hr>
<h2 id="3-async和await"><a href="#3-async和await" class="headerlink" title="3.async和await"></a>3.async和await</h2><p>​	书接上回，Promise名义上解决的回调地狱的问题，但实际在代码中依然充斥着大量的then函数。因此，async和await便诞生了，它们存在的意义便是让代码更加简洁。</p>
<h2 id="3-1async"><a href="#3-1async" class="headerlink" title="3.1async"></a>3.1async</h2><p>​	async是一个通过异步执行并隐式返回Promise作为结果的函数。async的使用很简单，只需要在函数前加上async关键字来表示函数是异步的。而异步函数的调用和普通函数相同，加括号调用就行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">yibu</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;我是异步&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">yibu</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment">//  [[Prototype]]: Promise</span></span><br><span class="line">	[[<span class="title class_">PromiseState</span>]]: <span class="string">&quot;fulfilled&quot;</span></span><br><span class="line">    [[<span class="title class_">PromiseResult</span>]]: <span class="string">&quot;我是异步&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	由上可知，async返回的Promise对象带有state和result，原因是调用异步函数时，内部会调用Promise.resolve（）方法将它转化为一个Promise对象返回；如果异步函数内部抛出错误，内部就会调用Promise.reject（）返回一个Promise对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">yibu2</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`我错了`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">yibu2</span>())</span><br><span class="line"><span class="comment">//[[Prototype]]: Promise</span></span><br><span class="line">[[<span class="title class_">PromiseState</span>]]: <span class="string">&quot;rejected&quot;</span></span><br><span class="line">[[<span class="title class_">PromiseResult</span>]]: <span class="title class_">Error</span>: 我错了</span><br></pre></td></tr></table></figure>

<p>如果想要获取async函数的结果，就可以调用then或catch。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">yibu3</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`又是我`</span> </span><br><span class="line">    &#125;</span><br><span class="line">	yibu3.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(value))</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我先去了`</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//我先去了</span></span><br><span class="line"><span class="comment">//又是我</span></span><br></pre></td></tr></table></figure>

<p>可以看到，then能够获取async的结果并放入异步队列，且同步代码先于异步代码执行。</p>
<hr>
<h2 id="3-2await"><a href="#3-2await" class="headerlink" title="3.2await"></a>3.2await</h2><p>​	根据MDN的定义，await 用于等待一个 Promise 成功并获取它成功之后的值。用人话说，await只能放入async函数中，并在之后接上一个能够返回Promise对象的表达式。它等待Promise对象执行完毕，并返回结果。事实上，await可以用于任意表达式，所以await后面可以接普通函数，只是不常用而已。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">function</span> <span class="title function_">what</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`这是什么`</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">question</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> promise1 = <span class="keyword">await</span> <span class="title function_">what</span>()</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(promise1)</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="title function_">question</span>()</span><br><span class="line"><span class="comment">//这是什么</span></span><br></pre></td></tr></table></figure>

<p>​	事实上，await在等待一个Promise对象时，会阻塞函数后面的代码，等待Promise对象resolve&#x2F;reject，然后得到resolve&#x2F;reject的值，作为await表达式的结果；如果等到了一个非Promise对象，那么它会隐式地返回一个resolve的Promise对象。</p>
<h2 id="3-3它们有毛线用呢"><a href="#3-3它们有毛线用呢" class="headerlink" title="3.3它们有毛线用呢"></a>3.3它们有毛线用呢</h2><p>​	还是那句老话，async和await能够使代码更简洁。</p>
<p>​	举个例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">function</span> <span class="title function_">wuhu</span>(<span class="params">name</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">				<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">					<span class="title function_">resolve</span>(name + <span class="string">`,`</span> +  <span class="string">`李在赣神魔`</span>)</span><br><span class="line">				&#125;),<span class="number">2000</span>&#125;)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line">			<span class="keyword">let</span> result1 = <span class="keyword">await</span> <span class="title function_">wuhu</span>(<span class="string">`蔚`</span>)</span><br><span class="line">			<span class="keyword">let</span> result2 = <span class="keyword">await</span> <span class="title function_">wuhu</span>(<span class="string">`泽丽`</span>)</span><br><span class="line">			<span class="keyword">let</span> result3 = <span class="keyword">await</span> <span class="title function_">wuhu</span>(<span class="string">`瑞兹`</span>)</span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>([result1,result2,result3]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="title function_">test</span>()</span><br><span class="line"><span class="comment">//[ &quot;蔚,李在赣神魔&quot;</span></span><br><span class="line">	<span class="string">&quot;泽丽,李在赣神魔&quot;</span></span><br><span class="line">	<span class="string">&quot;瑞兹,李在赣神魔&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>​	你可能没看出来，那再举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">wuhu</span>(<span class="params">name</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">			<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">				<span class="title function_">resolve</span>(name + <span class="string">`,`</span> +  <span class="string">`李在赣神魔`</span>)</span><br><span class="line">			&#125;),<span class="number">2000</span>&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="title function_">wuhu</span>(<span class="string">`蔚`</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span>&#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="title function_">wuhu</span>(<span class="string">`泽丽`</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span>&#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="title function_">wuhu</span>(<span class="string">`瑞兹`</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span>&#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<p>​	显然，第二种写法更加抽象，当then使用足够多时，你绝对不会想看下去，所以await在处理then链式调用方面还是很有用的。</p>
<hr>
<h2 id="3-2（补）阻塞"><a href="#3-2（补）阻塞" class="headerlink" title="3.2（补）阻塞"></a>3.2（补）阻塞</h2><p>​	再来仔细说一下阻塞。当遇到await时，会阻塞函数<strong>内部</strong>（不是全部）处于它后面的代码，再去执行函数外部的同步代码；当外部的同步代码全部执行完成，再回到改函数执行剩余的代码。当然，微任务队列的代码会优先处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">function</span> <span class="title function_">who</span>(<span class="params">value</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">				<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">					<span class="title function_">resolve</span>(value)</span><br><span class="line">				&#125;,<span class="number">4000</span>)</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">after</span>(<span class="params"></span>)&#123;</span><br><span class="line">			<span class="keyword">let</span> promise1 = <span class="keyword">await</span> <span class="title function_">who</span>(<span class="string">&#x27;369:&#x27;</span>)</span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>(promise1);</span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我被阻塞了`</span>);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="title function_">after</span>()</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我没被阻塞`</span>)</span><br><span class="line"><span class="comment">//我没被阻塞</span></span><br><span class="line"><span class="comment">// 4s后 -&gt;&#x27;369:&#x27;  我被阻塞了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	讲一下执行过程：</p>
<p>调用after函数，里面遇到了await，代码就暂停到这，不再继续执行，等待后面的who（’369:’）执行完毕，4秒后返回了结果值赋值给promise1并打印，暂停结束，代码继续执行console.log语句。</p>
<p>​	而且，js引擎在等待Promise.resolve时，并没有真正的停止工作，它还可以处理其他一些事情。比如在after（）函数后console.log()一下，我们会发现外部的console.log()语句会先执行。</p>
<p>​	再来一个</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">first</span>(<span class="params"></span>)&#123;</span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我先来的`</span>);</span><br><span class="line">			<span class="keyword">await</span> <span class="title function_">second</span>()</span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我最后`</span>);</span><br><span class="line">			<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">				<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`第一定时器`</span>);</span><br><span class="line">			&#125;,<span class="number">0</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">second</span>(<span class="params"></span>)&#123;</span><br><span class="line">			<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">				<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`第二定时器`</span>);</span><br><span class="line">				</span><br><span class="line">			&#125;,<span class="number">0</span>)</span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`再到我`</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="title function_">first</span>()</span><br><span class="line"></span><br><span class="line">		<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`第三定时器`</span>);</span><br><span class="line">		&#125;,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我在第三`</span>);</span><br><span class="line"><span class="comment">// 我先来的</span></span><br><span class="line"><span class="comment">// 再到我</span></span><br><span class="line"><span class="comment">// 我在第三</span></span><br><span class="line"><span class="comment">// 我最后</span></span><br><span class="line"><span class="comment">// 第二定时器</span></span><br><span class="line"><span class="comment">// 第三定时器</span></span><br><span class="line"><span class="comment">// 第一定时器</span></span><br></pre></td></tr></table></figure>

<p>​	再讲一下执行过程：</p>
<p>首先执行first（），打印出”我先来的”。</p>
<p>然后遇到await second（），在second（）中遇到第二定时器，将其加入宏任务队列，在执行同步代码打印”再到我”。</p>
<p>因为seconde（）阻塞了后面代码的执行，所以后面代码加入微任务队列。再到第三定时器，将其加入宏任务队列，之后打印“我在第三”。</p>
<p>因为同步代码执行完成，先执行微任务队列，打印“我最后”，再将第一定时器加入宏任务队列。</p>
<p>最后执行宏任务队列，按照先进先出的原则依次打印。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">const</span> <span class="title function_">first</span> = (<span class="params"></span>) =&gt; (<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">7</span>);</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line">                	<span class="title function_">resolve</span>(<span class="number">6</span>);</span><br><span class="line">                	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">8</span>)</span><br><span class="line">                	&#125;, <span class="number">0</span>)</span><br><span class="line">                <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="number">2</span>);</span><br><span class="line">            p.<span class="title function_">then</span>(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(arg);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        <span class="title function_">first</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(arg);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line"><span class="comment">//3,7,4,1,2,5,8</span></span><br></pre></td></tr></table></figure>



<p>​	</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://159357254680.github.io/2024/11/01/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/01/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2024-11-01 21:30:53 / Modified: 21:30:04" itemprop="dateCreated datePublished" datetime="2024-11-01T21:30:53+08:00">2024-11-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">John Doe</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
